#!/usr/bin/env python
"""
Telepresence CLI tool, a thin wrapper around the
datawire/telepresence-local Docker image.

Should be written to support Python 2 and Python 3 for ease of distribution.
"""

from __future__ import print_function

import sys

import argparse
import atexit
import collections
import os
import os.path
import signal
import socket
import webbrowser

from copy import deepcopy
from functools import wraps
from shutil import rmtree, copy
from subprocess import check_output, Popen, CalledProcessError, check_call
from tempfile import mkdtemp, mkstemp, NamedTemporaryFile
from time import sleep, time
from traceback import print_exc

import dpath
import yaml
import pprint

if sys.version_info.major == 2:
    from urllib import quote_plus
    from StringIO import StringIO
    input = __builtins__.raw_input

    def fdopen(fd, mode):
        return os.fdopen(fd, mode)
else:
    # Python 3
    from io import StringIO
    from urllib.parse import quote_plus
    unicode = str

    def fdopen(fd, mode):
        return os.fdopen(fd, mode, encoding="utf-8")

# Don't modify next line without modifying corresponding line in
# .bumpversion.cfg:
__version__ = "0.21"
# Test runs can override version so we use specific custom Docker images:
if os.environ.get("TELEPRESENCE_VERSION") is not None:
    __version__ = os.environ["TELEPRESENCE_VERSION"]

LOCAL_VERSION = os.environ.get("TELEPRESENCE_LOCAL_VERSION", __version__)
K8S_VERSION = os.environ.get("TELEPRESENCE_K8S_VERSION", __version__)

REGISTRY = os.environ.get("TELEPRESENCE_REGISTRY", "datawire")

LOCAL_IMAGE_NAME = "%s/telepresence-local:%s" % (REGISTRY, LOCAL_VERSION)
K8S_IMAGE_NAME = "%s/telepresence-k8s:%s" % (REGISTRY, K8S_VERSION)

def random_name():
    """Return a random name for a container."""
    return "telepresence-{}-{}".format(time(), os.getpid()).replace(".", "-")


def get_ip():
    """IP for this machine."""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 53))
    result = s.getsockname()[0]
    s.close()
    return result


class Runner(object):
    """Context for running subprocesses."""

    def __init__(self, logfile):
        """
        :param logfile: file-like object to write logs to.
        """
        self.logfile = logfile

    @classmethod
    def open(cls, logfile_path):
        """
        :return: File-like object for the given logfile path.
        """
        if logfile_path == "-":
            return cls(sys.stdout)
        else:
            # Wipe existing logfile, and use line buffering so data gets
            # written out immediately.
            if os.path.exists(logfile_path):
                os.remove(logfile_path)
            return cls(open(logfile_path, "a", buffering=1))

    def write(self, message):
        """Write a message to the log."""
        self.logfile.write(message)
        self.logfile.flush()

    def check_call(self, *args, **kwargs):
        """Run a subprocess, make sure it exited with 0."""
        self.write("Running: {}\n".format(args))
        check_call(*args, stdout=self.logfile, stderr=self.logfile, **kwargs)

    def get_output(self, *args, **kwargs):
        """Return (stripped) command result as unicode string."""
        self.write("Running: {}\n".format(args))
        return unicode(
            check_output(*args, stderr=self.logfile, **kwargs).strip(), "utf-8"
        )

    def popen(self, *args, **kwargs):
        """Return Popen object."""
        self.write("Running: {}\n".format(args))
        return Popen(*args, stderr=self.logfile, stdout=self.logfile, **kwargs)


def parse_args():
    """Create a new ArgumentParser and parse sys.argv."""
    parser = argparse.ArgumentParser()
    parser.add_argument('--version', action='version', version=__version__)
    parser.add_argument(
        "--logfile",
        default="./telepresence.log",
        help=(
            "The path to write logs to. '-' means stdout, "
            "default is './telepresence.log'."
        )
    )
    group_deployment = parser.add_mutually_exclusive_group(required=True)
    group_deployment.add_argument(
        "--deployment",
        help=(
            "The name of the Kubernetes Deployment where the " +
            "datawire/telepresence-k8s image is running."
        )
    )
    group_deployment.add_argument(
        '--new-deployment',
        dest="new_deployment",
        help=(
            "Create a new Deployment in Kubernetes where the "
            "datawire/telepresence-k8s image will run."
        )
    )
    group_deployment.add_argument(
        '--kubernetes-file', '-f',
        action='append',
        dest="k8s_resources",
        help=(
            "Use an existing Kubernetes resource file to control "
            "where the datawire/telepresence-k8s image will run."
        )
    )

    parser.add_argument(
        "--expose",
        type=int,
        action='append',
        default=[],
        help=(
            "Port number in local container that will be " +
            "exposed to Kubernetes."
        )
    )
    parser.add_argument(
        "--proxy",
        action='append',
        default=[],
        help=(
            "<host>:<port> that will be proxied via Kubernetes. "
            "This is unnecessary when using --run."
        ),
    )
    group_run = parser.add_mutually_exclusive_group(required=True)
    group_run.add_argument(
        "--run-shell",
        dest="runshell",
        action="store_true",
        help="Run a local shell that will be proxied to/from Kubernetes.",
    )
    group_run.add_argument(
        "--docker-run",
        dest="docker_run_args",
        metavar="DOCKER-RUN-ARGUMENTS",
        nargs=argparse.REMAINDER,
        help=(
            "All remaininding arguments will be passed to "
            "`docker run`, e.g. '-i -t alpine:3.5 /bin/sh'."
        )
    )
    return parser.parse_args()


def maybe_sudo(args):
    docker_path = "/var/run/docker.sock"
    if (os.path.exists(docker_path) and not os.access(docker_path, os.W_OK)):
        return ["sudo"] + args
    else:
        return args


def stop_proxy(runner, container_name):
    container_id = runner.get_output(
        maybe_sudo([
            "docker", "ps", "-q", "--filter", "name=" + container_name
        ])
    ).strip()
    if container_id:
        if sys.stderr.isatty():
            print("Shutting proxy down...", file=sys.stderr)
        runner.get_output(maybe_sudo(["docker", "stop", container_id]))


def stop_container(runner, container_id):
    if container_id in runner.get_output(
        maybe_sudo(["docker", "ps", "-q", "--no-trunc"])
    ):
        runner.get_output(maybe_sudo(["docker", "stop", container_id]))

def dpath_get(obj, glob, default=None):
    try:
        return dpath.util.get(obj, glob)
    except KeyError:
        return default

def dpath_set(obj, glob, value):
    return dpath.util.new(obj, glob, value)

class Deployment(object):
    """
    This is the thing that collects all the information we're going
    to use to actually deploy stuff to Kubernetes and run the proxy.
    'Deployment' is probably a crappy name, actually...
    """

    def __init__(self, runner):
        self.name = None
        self.runner = runner

        self.managed_resources = {
            'deployment': [],
            'service': [],
            'other': []
        }

        self.exposed_ports = []

    def get_adapted_resource(self, resource, mods):
        adapted_resource = deepcopy(resource)

        for path, value in mods:
            dpath_set(adapted_resource, path, value)

        return adapted_resource

    def write_resource(self, resource, mods):
        adapted_fd, adapted_path = mkstemp(suffix=".yaml")
        adapted_file = fdopen(adapted_fd, "w")

        yaml.safe_dump(resource, stream=adapted_file, encoding="utf-8")

        return adapted_path

    def add_managed_resource(self, name, kind, starter, stopper):
        if (kind == 'deployment') and not self.name:
            self.name = name

        print("%s: add %s\n%s\n%s\n%s" % (self.name, kind, name, starter, stopper))

        self.managed_resources[kind].append( (name, starter, stopper) )

    def add_exposed_port(self, name, port):
        self.exposed_ports.append((name, port))

    def add_k8s_resource(self, resource_path):
        """Load up a Kubernetes resource from a file."""
        # We don't know if this resource is JSON or YAML, but fortunately
        # PyYAML can load both. [ :) ]

        resources = yaml.safe_load_all(open(resource_path, "r").read())

        # As what kind of thing will we add this?
        resource_file_type = None

        # Some resources (like deployments) will need to be adapted for us.
        adapted_resources = []

        # We might not need to actually write these out...
        must_save_adapted_resources = False

        for resource in resources:
            # What exactly did we get back? We need it to be a dictionary.
            if not isinstance(resource, collections.Mapping):
                raise Exception("resource path %s does not specify an actual Kubernetes resource" % resource_path)

            # OK, so far so good. What is this thing?
            resource_type = dpath_get(resource, "kind")

            if resource_type is None:
                raise Exception("resource path %s has no kind" % resource_path)

            resource_name = dpath_get(resource, "/metadata/name")

            if resource_name is None:
                raise Exception("resource path %s has no name" % resource_path)

            if resource_type == 'Deployment':
                # It's a deployment, which means that we'll add this file as a
                # deployment.

                resource_file_type = 'deployment'

                # XXX labels??

                adapted_resource = self.get_adapted_resource(
                    resource,
                    [
                        ( "/spec/replicas", 1 ),
                        ( "/spec/template/spec/containers/0/image",
                          K8S_IMAGE_NAME )
                    ]
                )

                adapted_resources.append(adapted_resource)

                # Remember that we've actually changed something.
                must_save_adapted_resources = True

            elif resource_type == 'Service':
                # It's a service. Only add it as a service, though, if we shouldn't
                # already add it as a deployment.

                if resource_file_type != 'deployment':
                    resource_file_type = 'service'

                # XXX labels??

                ports = dpath_get(resource, "/spec/ports")

                if not ports:
                    raise Exception("service resource %s has no ports" % resource_path)

                adapted_resources.append(resource)

                for port in ports:
                    exposed_port = port.get('targetPort', None)

                    if exposed_port is None:
                        exposed_port = port.get('port', None)

                    if exposed_port is not None:
                        self.add_exposed_port(resource_name, exposed_port)
                    else:
                        raise Exception("Service %s at %s has no port to expose?" %
                                        (resource_name, resource_path))

            else:
                # We don't know what this is. Set the type to 'other' only if it's not
                # already set.

                if not resource_file_type:
                    resource_file_type = 'other'

                adapted_resources.append(resource)

                # adapted_path = self.write_adapted_resource(
                #     resource,

                # self.add_managed_resource(
                #     resource_name,
                #     "deployment",
                #     [ "kubectl", "apply", "-f", adapted_path ],
                #     [ "kubectl", "delete", "--ignore-not-found", "-f", adapted_path ]
                # )

                # self.add_managed_resource(
                #     resource_name,
                #     "service",
                #     [ "kubectl", "apply", "-f", resource_path ],
                #     [ "kubectl", "delete", "--ignore-not-found", "-f", resource_path ]
                # )

                # self.add_managed_resource(
                #     resource_name,
                #     "other",
                #     [ "kubectl", "apply", "-f", resource_path ],
                #     [ "kubectl", "delete", "--ignore-not-found", "-f", resource_path ]
                # )

        # OK, once here, we should know how to add this, and have a list of
        # adapted resources ready to go. Assume for the moment that we didn't
        # actually change anything...

        adapted_path = resource_path

        # ...and then actually check. Must we write out the adapted resources?

        if must_save_adapted_resources:
            # Yes. Hit it.

            adapted_fd, adapted_path = mkstemp(suffix=".yaml")
            adapted_file = fdopen(adapted_fd, "w")

            yaml.safe_dump_all(adapted_resources, stream=adapted_file,
                               encoding="utf-8")

        # Once that's done, add this resource to our stuff to manage.

        self.add_managed_resource(
            resource_name,
            resource_file_type,
            [ "kubectl", "apply", "-f", adapted_path ],
            [ "kubectl", "delete", "--ignore-not-found", "-f", adapted_path ]
        )

    def start(self):
        print("...starting K8s things")
        self.run_things(1)

    def stop(self):
        print("...stopping K8s things")
        self.run_things(2)

    def run_things(self, which):
        for rtype in [ 'deployment', 'service', 'other' ]:
            for thing in self.managed_resources[rtype]:
                print("%s %s: %s" % (rtype, thing[0], thing[which]))
                self.runner.get_output(thing[which])

def deployment_for_args(runner, args):
    deployment = Deployment(runner)

    # If they've given any deployment files, load those up.
    if args.k8s_resources:
        for path in args.k8s_resources:
            deployment.add_k8s_resource(path)
    elif args.new_deployment:
        deployment_name = args.new_deployment

        starter = [
            "kubectl", "run", "--generator", "deployment/v1beta1",
            deployment_name, "--image=%s" % K8S_IMAGE_NAME
        ]

        stopper = [ 
            "kubectl", "delete", "--ignore-not-found", "service,deployment", deployment_name
        ]

        for port in args.expose:
            deployment.add_exposed_port('cmdline', port)
            starter.append("--port={}".format(port))

        if args.expose:
            starter.append("--expose")

        deployment.add_managed_resource(deployment_name, starter, stopper)
    elif args.deployment:
        # Save the deployment name...
        deployment_name = args.deployment

        # ...but we needn't run any deployment command.
        starter = [ "echo", "Using existing deployment %s" % deployment_name ]
        stopper = [ "echo", "Not stopping existing deployment %s" % deployment_name ]

        deployment.add_managed_resource(deployment_name, starter, stopper)

    return deployment

def start_proxy(runner, deployment, args):
    """`telepresence start`."""
    if sys.stderr.isatty():
        print("Starting proxy...", file=sys.stderr)

    if deployment:
        atexit.register(deployment.stop)
        deployment.stop()
        deployment.start()
        sleep(5)  # XXX oh god

    # OK. Now it's on to the local stuff. Start with snaring our home directory.
    home_path = os.path.expanduser("~")

    # On OS X /tmp is shareable via Docker, but default location of temporary
    # files is not (https://docs.docker.com/docker-for-mac/osxfs/):
    tempdir = mkdtemp(dir="/tmp")
    container_id = random_name()

    docker_cmd = maybe_sudo([
        "docker",
        "run",
        # Cleanup on shutdown:
        "--rm",
        # Name so we can identify it:
        "--name",
        container_id,
        # XXX Run with TTY, for some reason need this to capture stdout
        "-t",
        # Mount $HOME so we have access to kubectl configuration:
        "-v",
        home_path + ":/opt:ro",
        # Minikube looks in absolute path for home, so also mount in way that
        # matches host path:
        "-v",
        "{}:{}:ro".format(home_path, home_path),
    ])

    if args.runshell:
        # We're using a local command, which means it will be using a SOCKS
        # proxy, so expose the local SOCKS port to the host machine:
        docker_cmd.extend([
            "-p",
            ":9050",
        ])
        # We want the exposed host to be the external machine, not the Docker
        # container:
        expose_host = get_ip()
    else:
        # We're running our local process inside Docker, so we're exposing
        # Docker container's IP (which is 127.0.0.1 since this will run in a
        # container):
        expose_host = "127.0.0.1"

    docker_cmd.extend([
        # Mount local directory, where env file will be written out:
        "-v",
        tempdir + ":/output",
        # Name of image:
        LOCAL_IMAGE_NAME,
        # Arguments: <uid>, <deployment-name>
        str(os.getuid()),
        deployment.name,
        # Arguments: <port1,port2>, <proxy1,proxy2>, <expose_host>
        ",".join([ "%s" % x[1] for x in deployment.exposed_ports ]),
        # We don't need to do special proxying when using SOCKS-based --run:
        ",".join([] if args.runshell else args.proxy),
        expose_host,
    ])

    print("docker cmd %s" % docker_cmd)

    p = runner.popen(docker_cmd)

    atexit.register(stop_proxy, runner, container_id)
    return tempdir, container_id, p

TORSOCKS_CONFIG = """
# Allow process to listen on ports:
AllowInbound 1
# Allow process to connect to localhost:
AllowOutboundLocalhost 1
# Connect to custom port for SOCKS server:
TorPort {}
"""


def sip_workaround():
    """
    Workaround System Integrity Protection.

    Newer OS X don't allow injecting libraries into binaries in /bin, /sbin and
    /usr. We therefore make a copy of them and modify $PATH to point at their
    new location. It's only ~100MB so this should be pretty fast!
    """
    protected = {"/bin", "/sbin", "/usr/sbin", "/usr/bin"}
    # Remove protected paths from $PATH:
    paths = [p for p in os.environ["PATH"].split(":") if p not in protected]
    # Add temp dir
    bin_dir = mkdtemp()
    paths.insert(0, bin_dir)
    atexit.register(rmtree, bin_dir)
    for directory in protected:
        for file in os.listdir(directory):
            try:
                copy(os.path.join(directory, file), bin_dir)
            except IOError:
                continue
            os.chmod(os.path.join(bin_dir, file), 0o775)
    # Return new $PATH
    return ":".join(paths)


def wait_for_exit(runner, process, container_name):
    """Given Popen and container ID, wait for one of them to die."""
    while True:
        exit_code = process.poll()
        if exit_code is not None:
            sys.exit(exit_code)
        alive = unicode(
            check_output(
                maybe_sudo([
                    "docker", "ps", "-q", "--filter", "name=" + container_name
                ])
            ), "utf-8"
        ).strip()
        if not alive:
            if sys.stderr.isatty:
                print(
                    "Proxy to Kubernetes exited. This is typically due to a"
                    " lost connection.",
                    file=sys.stderr
                )
            sys.exit(3)
        sleep(0.1)


def run_local_command(runner, args, out_env, proxy_container_name):
    """--run support, run command locally."""
    socks_port = int(
        runner.get_output(
            maybe_sudo(["docker", "port", proxy_container_name, "9050/tcp"])
        ).split(":")[-1]
    )
    with open(out_env, "r") as f:
        env = os.environ.copy()
        env.update(dict(line.split("=", 1) for line in f.read().splitlines()))
        env["PS1"] = "[TELEPRESENCE] " + env.get("PS1", "$ ")
    if sys.platform == "darwin":
        env["PATH"] = sip_workaround()
    # Create custom torsocks.conf, since some options we want (in particular,
    # port) aren't accessible via env variables in older versions of torconf:
    with NamedTemporaryFile(mode="w+", delete=False) as tor_conffile:
        tor_conffile.write(TORSOCKS_CONFIG.format(socks_port))
    env["TORSOCKS_CONF_FILE"] = tor_conffile.name
    if runner.logfile is not sys.stdout:
        env["TORSOCKS_LOG_FILE_PATH"] = runner.logfile.name
    # Don't use runner.popen() since we want to give program access to current
    # stdout and stderr if it wants it.
    env["PROMPT_COMMAND"] = (
        'PS1="@{}|$PS1";unset PROMPT_COMMAND'.format(
            runner.get_output(["kubectl", "config", "current-context"]).strip()
        )
    )
    # Make sure we use "bash", no "/bin/bash", so we get the copied version on
    # OS X:
    p = Popen(["torsocks", "bash"], env=env)

    def terminate_if_alive():
        os.remove(tor_conffile.name)
        if p.poll() is None:
            p.terminate()

    atexit.register(terminate_if_alive)
    wait_for_exit(runner, p, proxy_container_name)


def run_docker_command(runner, args, out_env, proxy_container_name):
    """--run-docker support, run command via Docker."""
    # XXX argparse sucks need to switch to something else
    if args.docker_run_args and args.docker_run_args[0] == "--":
        args.docker_run_args.pop(0)
    if sys.stderr.isatty():
        print("Starting local container...", file=sys.stderr)
    command = maybe_sudo([
        "docker",
        "run",
        # Use network namespace of telepresence-local container:
        "--net=container:" + proxy_container_name,
        # Use environment variables written out from telepresence-local, to
        # match Kubernets:
        "--env-file={}".format(out_env),
        # Set a label so we can easily find this container later:
        "--label",
        "telepresence-container=" + proxy_container_name,
    ]) + args.docker_run_args
    # Don't want to capture stderr here, since user may want to interact with
    # this container, so we don't use runner.popen:
    p = Popen(command)

    def terminate_if_alive():
        cid = runner.get_output(
            maybe_sudo([
                "docker", "ps", "-q", "--no-trunc", "--filter",
                "label=telepresence-container=" + proxy_container_name
            ])
        ).strip()
        # May have already exited, in which case cid is empty:
        if cid:
            stop_container(runner, cid)

    atexit.register(terminate_if_alive)
    wait_for_exit(runner, p, proxy_container_name)


BUG_REPORT_TEMPLATE = u"""\
### What were you trying to do?

(please tell us)

### What did you expect to happen?

(please tell us)

### What happened instead?

(please tell us - the traceback is automatically included, see below)

### Automatically included information

Command line: `{}`
Version: `{}`
Python version: `{}`
kubectl version: `{}`
Docker version: `{}`
OS: `{}`
Traceback:

```
{}
```

Logs:

```
{}
```
"""


class handle_unexpected_errors(object):
    """Decorator that catches unexpected errors."""

    def __init__(self, logfile):
        self.logfile = logfile

    def __call__(self, f):
        def safe_output(args):
            try:
                return unicode(check_output(args), "utf-8").strip()
            except CalledProcessError as e:
                return "(error: {})".format(e)

        @wraps(f)
        def call_f(*args, **kwargs):
            try:
                return f(*args, **kwargs)
            except SystemExit:
                raise
            except KeyboardInterrupt:
                raise SystemExit(0)
            except Exception as e:
                logs = "Not available"
                if self.logfile != "-" and os.path.exists(self.logfile):
                    try:
                        with open(self.logfile, "r") as logfile:
                            logs = logfile.read()
                    except Exception as e:
                        logs += "error ({})".format(e)
                errorf = StringIO()
                print_exc(file=errorf)
                error = errorf.getvalue()
                print(
                    "\nLooks like there's a bug in our code. Sorry about that!"
                    " You may able to find more details in the logs "
                    "(which are written to telepresence.log by default).\n\n"
                    "Here's the traceback:\n\n" + error + "\n"
                )
                if input(
                    "Would you like to file an issue in our issue tracker?"
                    " We'd really appreciate the help improving our "
                    "product. [Y/n]: ",
                ).lower() in ("y", ""):
                    url = (
                        "https://github.com/datawire/telepresence/issues/" +
                        "new?body="
                    )
                    body = quote_plus(
                        # Overly long URLs won't work:
                        BUG_REPORT_TEMPLATE.format(
                            sys.argv, __version__, sys.version,
                            safe_output([
                                "kubectl", "version", "--short", "--client"
                            ]),
                            safe_output(maybe_sudo(["docker", "version"])),
                            safe_output(["uname", "-a"]), error, logs
                        )[:4000]
                    )
                    webbrowser.open_new(url + body)
                else:
                    raise SystemExit(1)

        return call_f


def main():
    # Make SIGTERM do clean shutdown (in particular, we want atexit functions
    # to be called):
    def shutdown(signum, frame):
        raise SystemExit(0)

    signal.signal(signal.SIGTERM, shutdown)

    args = parse_args()
    runner = Runner.open(args.logfile)

    @handle_unexpected_errors(args.logfile)
    def go():
        # Make sure we can access Kubernetes:
        try:
            check_output(["kubectl", "cluster-info"])
        except (CalledProcessError, OSError, IOError) as e:
            sys.stderr.write("Error accessing Kubernetes: {}\n".format(e))
            raise SystemExit(1)
        # Make sure we're using local Docker:
        if "DOCKER_HOST" in os.environ:
            sys.stderr.write(
                "You appear to be using a remote Docker server ({}), "
                "but only a local Docker is supported. This may because "
                "you have run  `minikube docker-env` or otherwise set the "
                "DOCKER_HOST environment variable.\n".
                format(os.environ["DOCKER_HOST"])
            )
            raise SystemExit(1)
        # Make sure we can access Docker:
        try:
            check_output(maybe_sudo(["docker", "version"]))
        except (CalledProcessError, OSError, IOError) as e:
            sys.stderr.write("Error running Docker: {}\n".format(e))
            raise SystemExit(1)
        # Make sure we have torsocks:
        if args.runshell:
            try:
                check_output(["which", "torsocks"])
            except CalledProcessError as e:
                sys.stderr.write("Please install torsocks (v2.1 or later)\n")
                raise SystemExit(1)

        deployment = deployment_for_args(runner, args)

        tempdir, proxy_container_name, proxy_popen = start_proxy(runner, deployment, args)

        # Wait for proxy container to write out env file, indicating we're good
        # to go:
        out_env = os.path.join(tempdir, "docker.env")
        while not os.path.exists(out_env):
            print("no %s, sleeping" % out_env)
            sleep(1)

        if args.docker_run_args is not None:
            run_docker_command(runner, args, out_env, proxy_container_name)
        else:
            run_local_command(
                runner,
                args,
                os.path.join(tempdir, "unproxied.env"),
                proxy_container_name,
            )

    go()


if __name__ == '__main__':
    main()
