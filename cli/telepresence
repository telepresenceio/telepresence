#!/usr/bin/env python3
"""
Telepresence CLI tool: local development environment for a remote
Kubernetes cluster.
"""

import argparse
import atexit
import json
import os
import os.path
import signal
import socket
import sys
from functools import wraps
from shutil import rmtree, copy
from subprocess import (
    check_output, Popen, CalledProcessError, check_call, TimeoutExpired,
    STDOUT, DEVNULL
)
from tempfile import mkdtemp, NamedTemporaryFile
from time import sleep, time
from traceback import print_exc
import webbrowser
from io import StringIO
from urllib.parse import quote_plus
unicode = str

if sys.version_info[:2] < (3, 5):
    raise SystemExit("Telepresence requires Python 3.5 or later.")

# Don't modify next line without modifying corresponding line in
# .bumpversion.cfg:
__version__ = "0.44"
# Test runs can override version so we use specific custom Docker images:
if os.environ.get("TELEPRESENCE_VERSION") is not None:
    __version__ = os.environ["TELEPRESENCE_VERSION"]
REGISTRY = os.environ.get("TELEPRESENCE_REGISTRY", "datawire")

# This is a copy of the file in remote/id_rsa:
PRIVATE_RSA_KEY = b"""\
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA1/PNIB2ldDI7f/zGxpQSBXh5F3gs2xq6XMBGkkwWryqMqfMO
j96h+FpeYmH+c932gR6XgZLTowsaTqF8M0xO0TQq4wGnX/Q5HMZlAhrq3pLb+Sjv
6g7JQAooMmh76NimTdeDIqMBQgB4oDd4WyaLqv9Pzv1VaWFixY+Leb8lncN6C6Yb
riSXT4PaHvf2U6AI7yInPOdGCBHCeYDL2MXSxP84D4E7tWcvLHvgZcnK+bFwDQEZ
1F8C4VAxXR/VWXO77eLiLZddQl01HZtowjMqJoeZ5Bjvmp6r8kVGj1oOkSQdf9HG
dKaCQZvbOxzCvvGarrLVXQS+/YT1RCLXCa58UwIDAQABAoIBAQCxOmPY/Juh3evY
4QHdTP3xQWrXqQffFXNm1WHVhN6FCX2BqHkF96ej475cLaIfQ0WfuBSNAYvw3hbL
+1mr2+8/X/nmbaAIbq1EgUm6TY799TbUqBUlWNcvWGae4AL5GHx7m+gCUBajLTHS
A1QiMmMjhf7gmCY1ovflvSWxV/8uFhF3UU9XMdEfbUQICTtG0ol5q3P0hL3wb7Xq
9gR++3s4mlUQIXLRzRii0JsjNC3BWAZ49tkTjumr//iwxqkUnLkWUladC/qidTAa
XcZzkEpxBN73Wqa4dlVux3ScUuqh3PN0yihnO/RZ9gkF+dH6WMFy6YTKCcDenGcd
5QrAP5GBAoGBAPnyHB2KgXbeMrHFsYcj4j6kVEafbBUrROwInV1DJ1gqNv7ljKwI
8zExXjnldUSY3MJgL4j+R/2ImKg2tPJuhyyZGyRuEUJe+0FIxKbJiSh5ZgeIC+fg
QrV4Z27zOGtAKvd+qep7U/QUlEbb00gzNe5Phzdcpw8kXqLk8tGztuDBAoGBAN0u
5s7vWLPjH8h8s0SXfT9TyAUfQ+GOQKwuZVTPi2uPD6YYxADKkWyI4c/Q+hTaNDYH
3+9hgFedDHvB63N7g9CWGafikkburGfYo0ECujCBY1nI6V/+820bJjTrgGJzyGhe
wIosB9DftOKAo5DKtbhNFqW88AYoo9dECGSx4U4TAoGBALy0HKP0+Q+MbEupDQIR
hnNyz6nOHOTSmSN20ZAi7iZzILhLCGyuCSV/tzsQ0PtsSWd7BQhxqlpw8Yg2XWCX
L/js0wArFV69pQZB8S5XA/WJyg0vmoWC2/p0H+s1N8hJVucqOxCr8dNaYiQpPRfK
ihIU+upCSmJ1O/nRzr2h6BVBAoGAW9CtZTd8BeiBeBMzw4RzLIeV33J0Fjyb4h28
WLFy+apAX72mF4H/TiOgQUlJlsBhrhAkyFUcFsKNvQ3ptF2QgVTdv5BREnrfPJh0
ZHdCXQJJAKtjHUNTP3ZmrM8Z00Sm65RxrqnKcM18ZA3sWB2dw6zUeuZsaNIT+Tc3
mL0yftsCgYEAixjj9vjV2PVaiUdY9oSIN6dGKBDRAo6spdd7scszbiNaMvIulCFt
tb2kRtUVaxcOGDG3VhGDbmnpH0wzVDvXdEBGzH2LH/7/2LWZ5Zly+iCtdpNa/afC
vHKsWr/r9LljHBJaIvq2n37uc05T1nv4ca8YPFLLbfz6m58TD+SB/4E=
-----END RSA PRIVATE KEY-----
"""


def random_name():
    """Return a random name for a container."""
    return "telepresence-{}-{}".format(time(), os.getpid()).replace(".", "-")


def find_free_port():
    """
    Find a port that isn't in use.

    XXX race condition-prone.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        s.bind(("", 0))
        return s.getsockname()[1]
    finally:
        s.close()


def read_logs(logfile):
    """Read logfile, return string."""
    logs = "Not available"
    if logfile != "-" and os.path.exists(logfile):
        try:
            with open(logfile, "r") as logfile:
                logs = logfile.read()
        except Exception as e:
            logs += ", error ({})".format(e)
    return logs


class handle_unexpected_errors(object):
    """Decorator that catches unexpected errors."""

    def __init__(self, logfile):
        self.logfile = logfile

    def __call__(self, f):
        def safe_output(args):
            try:
                return unicode(check_output(args), "utf-8").strip()
            except CalledProcessError as e:
                return "(error: {})".format(e)

        @wraps(f)
        def call_f(*args, **kwargs):
            try:
                return f(*args, **kwargs)
            except SystemExit:
                raise
            except KeyboardInterrupt:
                raise SystemExit(0)
            except Exception as e:
                logs = read_logs(self.logfile)
                errorf = StringIO()
                print_exc(file=errorf)
                error = errorf.getvalue()
                print(
                    "\nLooks like there's a bug in our code. Sorry about that!"
                    "\n\n"
                    "Here's the traceback:\n\n" + error + "\n"
                )
                if self.logfile != "-":
                    print(
                        "And here are the last few lines of the logfile "
                        "(see {} for the complete logs):\n\n".format(
                            self.logfile
                        ) + "\n".join(logs.splitlines()[-20:]) + "\n"
                    )

                if input(
                    "Would you like to file an issue in our issue tracker?"
                    " We'd really appreciate the help improving our "
                    "product. [Y/n]: ",
                ).lower() in ("y", ""):
                    url = (
                        "https://github.com/datawire/telepresence/issues/" +
                        "new?body="
                    )
                    body = quote_plus(
                        # Overly long URLs won't work:
                        BUG_REPORT_TEMPLATE.format(
                            sys.argv, __version__, sys.version,
                            safe_output([
                                "kubectl", "version", "--short", "--client"
                            ]),
                            safe_output(["uname", "-a"]), error, logs[-1000:]
                        )[:4000]
                    )
                    webbrowser.open_new(url + body)
                else:
                    raise SystemExit(1)

        return call_f


class Runner(object):
    """Context for running subprocesses."""

    def __init__(self, logfile):
        """
        :param logfile: file-like object to write logs to.
        """
        self.logfile = logfile
        self.tempdir = mkdtemp()

    @classmethod
    def open(cls, logfile_path):
        """
        :return: File-like object for the given logfile path.
        """
        if logfile_path == "-":
            return cls(sys.stdout)
        else:
            # Wipe existing logfile, and use line buffering so data gets
            # written out immediately.
            if os.path.exists(logfile_path):
                os.remove(logfile_path)
            return cls(open(logfile_path, "a", buffering=1))

    def write(self, message):
        """Write a message to the log."""
        self.logfile.write(message)
        self.logfile.flush()

    def check_call(self, *args, **kwargs):
        """Run a subprocess, make sure it exited with 0."""
        self.write("Running: {}\n".format(args))
        check_call(
            *args,
            stdin=DEVNULL,
            stdout=self.logfile,
            stderr=self.logfile,
            **kwargs
        )

    def get_output(self, *args, stderr=None, **kwargs):
        """Return (stripped) command result as unicode string."""
        if stderr is None:
            stderr = self.logfile
        self.write("Running: {}\n".format(args))
        return unicode(
            check_output(*args, stdin=DEVNULL, stderr=stderr,
                         **kwargs).strip(), "utf-8"
        )

    def popen(self, *args, stdin=DEVNULL, **kwargs):
        """Return Popen object."""
        self.write("Running: {}\n".format(args))
        return Popen(
            *args,
            stdin=stdin,
            stderr=self.logfile,
            stdout=self.logfile,
            **kwargs
        )


@handle_unexpected_errors("-")
def parse_args():
    """Create a new ArgumentParser and parse sys.argv."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        allow_abbrev=False,  # can make adding changes not backwards compatible
        description=(
            "Telepresence: local development proxied to a remote Kubernetes "
            "cluster.\n\n"
            "Documentation: http://telepresence.io\n"
            "Real-time help: https://gitter.im/datawire/telepresence\n"
            "Issue tracker: https://github.com/datawire/telepresence/issues\n"
        )
    )
    parser.add_argument('--version', action='version', version=__version__)
    parser.add_argument(
        "--logfile",
        default="./telepresence.log",
        help=(
            "The path to write logs to. '-' means stdout, "
            "default is './telepresence.log'."
        )
    )
    group_deployment = parser.add_mutually_exclusive_group(required=True)
    group_deployment.add_argument(
        "--deployment",
        help=(
            "The name of the Kubernetes Deployment where the " +
            "datawire/telepresence-k8s image is running."
        )
    )
    group_deployment.add_argument(
        '--new-deployment',
        dest="new_deployment",
        help=(
            "Create a new Deployment in Kubernetes where the "
            "datawire/telepresence-k8s image will run."
        )
    )
    parser.add_argument(
        "--context",
        default=None,
        help=(
            "The Kubernetes context to use. Defaults to current kubectl"
            " context."
        )
    )
    parser.add_argument(
        "--namespace",
        default=None,
        help=(
            "The Kubernetes namespace to use. Defaults to kubectl's default"
            " for the current context, which is usually 'default'."
        )
    )
    parser.add_argument(
        "--expose",
        type=int,
        action='append',
        default=[],
        help=(
            "Port number in local container that will be " +
            "exposed to Kubernetes."
        )
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--run-shell",
        dest="runshell",
        action="store_true",
        help="Run a local shell that will be proxied to/from Kubernetes.",
    )
    group.add_argument(
        "--run",
        metavar=("COMMAND", "ARG"),
        dest="run",
        nargs=argparse.REMAINDER,
        help=(
            "Run the specified command arguments, e.g. "
            "'--run python myapp.py'."
        )
    )
    return parser.parse_args()


def kubectl(context, namespace, args):
    """Return command-line for running kubectl."""
    assert context is not None
    assert namespace is not None
    result = ["kubectl"]
    result.extend(["--context", context])
    result.extend(["--namespace", namespace])
    result += args
    return result


class RemoteInfo(object):
    """
    Information about the remote setup.

    :ivar namespace str: The Kubernetes namespace.
    :ivar deployment_name str: The name of the Deployment object.
    :ivar pod_name str: The name of the pod created by the Deployment.
    :ivar deployment_config dict: The decoded k8s object (i.e. JSON/YAML).
    :ivar container_config dict: The container within the Deployment JSON.
    :ivar container_name str: The name of the container.
    """

    def __init__(
        self,
        runner,
        namespace,
        deployment_name,
        pod_name,
        deployment_config,
    ):
        self.namespace = namespace
        self.deployment_name = deployment_name
        self.pod_name = pod_name
        self.deployment_config = deployment_config
        cs = deployment_config["spec"]["template"]["spec"]["containers"]
        containers = [c for c in cs if "telepresence-k8s" in c["image"]]
        if not containers:
            raise SystemExit(
                "Could not find container with image "
                "'datawire/telepresence-k8s' in pod {}.".format(pod_name)
            )
        self.container_config = containers[0]
        self.container_name = self.container_config["name"]

    def remote_telepresence_version(self):
        """Return the version used by the remote Telepresence container."""
        return self.container_config["image"].split(":")[-1]


def _get_service_names(environment):
    """Return names of Services, as used in env variable names."""
    # Order matters for service_keys, need it to be consistent with port
    # forwarding order in remote container.
    result = [
        key[:-len("_SERVICE_HOST")] for key in environment
        if key.endswith("_SERVICE_HOST")
    ]
    result.sort()
    return result


def _get_remote_env(runner, context, namespace, pod_name, container_name):
    """Get the environment variables in the remote pod."""
    env = runner.get_output(
        kubectl(
            context, namespace,
            ["exec", pod_name, "--container", container_name, "env"]
        )
    )
    result = {}
    for line in env.splitlines():
        key, value = line.split("=", 1)
        result[key] = value
    return result


def get_deployment_set_keys(remote_info):
    """Get the set of environment variables names set by the Deployment."""
    return set(
        [var["name"] for var in remote_info.container_config.get("env", [])]
    )


def get_env_variables(runner, remote_info, context):
    """
    Generate environment variables that match kubernetes.
    """
    # Get the environment:
    remote_env = _get_remote_env(
        runner, context, remote_info.namespace, remote_info.pod_name,
        remote_info.container_name
    )
    service_names = _get_service_names(remote_env)
    deployment_set_keys = get_deployment_set_keys(remote_info)
    # Tell local process about the remote setup, useful for testing and
    # debugging:
    socks_result = {
        "TELEPRESENCE_POD": remote_info.pod_name,
        "TELEPRESENCE_CONTAINER": remote_info.container_name
    }
    # ips proxied via socks, can copy addresses unmodified:
    for key, value in remote_env.items():
        if key in deployment_set_keys:
            # Copy over Deployment-set env variables:
            socks_result[key] = value
        for service_name in service_names:
            # Copy over Service env variables to SOCKS variant:
            if key.startswith(service_name + "_") and (
                key.endswith("_ADDR") or key.endswith("_PORT") or
                key.endswith("_PROTO") or key.endswith("_HOST") or
                key.endswith("_TCP")
            ):
                socks_result[key] = value
    return socks_result


def get_remote_info(runner, deployment_name, context, namespace):
    """Given the deployment name, return a RemoteInfo object."""
    assert context is not None
    assert namespace is not None
    try:
        deployment = json.loads(
            runner.get_output(
                kubectl(
                    context, namespace, [
                        "get",
                        "deployment",
                        "-o",
                        "json",
                        deployment_name,
                        "--export",
                    ]
                ),
                stderr=STDOUT
            )
        )
    except CalledProcessError as e:
        raise SystemExit(
            "Failed to find Deployment '{}': {}".
            format(deployment_name, str(e.stdout, "utf-8"))
        )

    expected_metadata = deployment["spec"]["template"]["metadata"]
    runner.write("Expected metadata for pods: {}\n".format(expected_metadata))
    pods = json.loads(
        runner.get_output(
            kubectl(
                context, namespace, ["get", "pod", "-o", "json", "--export"]
            )
        )
    )["items"]

    for pod in pods:
        name = pod["metadata"]["name"]
        phase = pod["status"]["phase"]
        runner.write(
            "Checking {} (phase {})...\n".
            format(pod["metadata"].get("labels"), phase)
        )
        if not set(expected_metadata.get("labels", {}).items()
                   ).issubset(set(pod["metadata"].get("labels", {}).items())):
            runner.write("Labels don't match.\n")
            continue
        # Metadata for Deployment will hopefully have a namespace. If not, fall
        # back to one we were given. If we weren't given one, best we can do is
        # choose "default".
        if (name.startswith(deployment_name + "-")
            and
            pod["metadata"]["namespace"] == deployment["metadata"].get(
                "namespace", namespace)
            and
            phase in (
                "Pending", "Running"
        )):
            runner.write("Looks like we've found our pod!\n")
            remote_info = RemoteInfo(
                runner,
                namespace,
                deployment_name,
                name,
                deployment,
            )
            # Ensure remote container is running same version as we are:
            if remote_info.remote_telepresence_version() != __version__:
                raise SystemExit((
                    "The remote datawire/telepresence-k8s container is " +
                    "running version {}, but this tool is version {}. " +
                    "Please make sure both are running the same version."
                ).format(
                    remote_info.remote_telepresence_version(), __version__
                ))
            # Wait for pod to be running:
            wait_for_pod(runner, remote_info, context)
            return remote_info

    raise RuntimeError(
        "Telepresence pod not found for Deployment '{}'.".
        format(deployment_name)
    )


def ssh(runner, ssh_port, args):
    """Connect to remote pod via SSH.

    Returns Popen object.
    """
    return runner.popen([
        "ssh",
        # SSH with no warnings:
        "-q",
        # Private key:
        "-i",
        runner.tempdir + "/id_rsa",
        # Don't validate host key:
        "-oStrictHostKeyChecking=no",
        # Don't store host key:
        "-oUserKnownHostsFile=/dev/null",
        # Ping once a second; after three retries will disconnect:
        "-oServerAliveInterval=1",
        # No shell:
        "-N",
        "-p",
        str(ssh_port),
        "main@localhost",
    ] + args)


def wait_for_ssh(runner, ssh_port):
    start = time()
    while time() - start < 30:
        try:
            runner.check_call([
                "ssh", "-q", "-p", str(ssh_port), "-oStrictHostKeyChecking=no",
                "-i", runner.tempdir + "/id_rsa",
                "-oUserKnownHostsFile=/dev/null", "main@localhost", "/bin/true"
            ])
        except CalledProcessError:
            sleep(0.25)
        else:
            return
    raise RuntimeError("SSH isn't starting.")


def wait_for_pod(runner, remote_info, context):
    start = time()
    while time() - start < 120:
        try:
            pod = json.loads(
                runner.get_output(
                    kubectl(
                        context, remote_info.namespace,
                        ["get", "pod", remote_info.pod_name, "-o", "json"]
                    )
                )
            )
        except CalledProcessError:
            sleep(0.25)
            continue
        if pod["status"]["phase"] == "Running":
            for container in pod["status"]["containerStatuses"]:
                if container["name"] == remote_info.container_name and (
                    container["ready"]
                ):
                    return
        sleep(0.25)
    raise RuntimeError(
        "Pod isn't starting or can't be found: {}".format(pod["status"])
    )


def connect(
    runner,
    remote_info,
    local_exposed_ports,
    context,
):
    """
    Start all the processes that handle remote proxying.

    Return list of Popen instances.
    """
    processes = []
    ssh_port = find_free_port()

    # forward remote port to here, by tunneling via remote SSH server:
    processes.append(
        runner.popen(
            kubectl(
                context, remote_info.namespace, [
                    "port-forward", remote_info.pod_name,
                    "{}:2022".format(ssh_port)
                ]
            )
        )
    )
    atexit.register(killall, processes)
    wait_for_ssh(runner, ssh_port)

    for port_number in local_exposed_ports:
        processes.append(
            ssh(
                runner, ssh_port,
                ["-R", "*:{}:127.0.0.1:{}".format(port_number, port_number)]
            )
        )

    # start tunnel to remote SOCKS proxy, for telepresence --run.
    socks_port = find_free_port()
    processes.append(
        ssh(
            runner, ssh_port,
            ["-L", "127.0.0.1:{}:127.0.0.1:9050".format(socks_port)]
        ),
    )

    return processes, socks_port, ssh_port


def killall(processes):
    for p in processes:
        if p.poll() is None:
            p.terminate()
    for p in processes:
        try:
            p.wait(timeout=1)
        except TimeoutExpired:
            p.kill()
            p.wait()


def start_proxy(runner, args):
    """Start the kubectl port-forward and SSH clients that do the proxying."""
    if sys.stderr.isatty():
        print("Starting proxy...", file=sys.stderr)

    # Figure out explicit namespace and context:
    kubectl_config = json.loads(
        runner.get_output(["kubectl", "config", "view", "-o", "json"]))
    # First, figure out the context:
    if args.context is None:
        # We're using the current context:
        args.context = kubectl_config["current-context"]
    # Then, figure out the namespace:
    if args.namespace is None:
        # We're using the namespace for the given context, which if unset is
        # "default".
        for context_setting in kubectl_config["contexts"]:
            if context_setting["name"] == args.context:
                args.namespace = context_setting["context"].get(
                    "namespace", "default")
                break

    if args.deployment is None:
        # This implies --new-deployment:
        args.deployment = args.new_deployment

        def remove_existing_deployment():
            runner.get_output(
                kubectl(
                    args.context, args.namespace, [
                        "delete", "--ignore-not-found", "service,deployment",
                        args.deployment
                    ]
                )
            )

        atexit.register(remove_existing_deployment)
        remove_existing_deployment()
        command = kubectl(
            args.context, args.namespace, [
                "run",
                "--generator",
                "deployment/v1beta1",
                "--limits=memory=256Mi",
                "--requests=memory=64Mi",
                args.deployment,
                "--image={}/telepresence-k8s:{}".format(REGISTRY, __version__),
            ]
        )
        for port in args.expose:
            command.append("--port={}".format(port))
        if args.expose:
            command.append("--expose")
        runner.get_output(command)

    remote_info = get_remote_info(
        runner, args.deployment, args.context, args.namespace
    )

    processes, socks_port, ssh_port = connect(
        runner,
        remote_info,
        args.expose,
        args.context,
    )

    # Get the environment variables we want to copy from the remote pod; it may
    # take a few seconds for the SSH proxies to get going:
    start = time()
    while time() - start < 5:
        try:
            env = get_env_variables(runner, remote_info, args.context)
            break
        except CalledProcessError:
            sleep(0.25)

    return processes, env, socks_port, ssh_port, remote_info


TORSOCKS_CONFIG = """
# Allow process to listen on ports:
AllowInbound 1
# Allow process to connect to localhost:
AllowOutboundLocalhost 1
# Connect to custom port for SOCKS server:
TorPort {}
"""


def sip_workaround():
    """
    Workaround System Integrity Protection.

    Newer OS X don't allow injecting libraries into binaries in /bin, /sbin and
    /usr. We therefore make a copy of them and modify $PATH to point at their
    new location. It's only ~100MB so this should be pretty fast!
    """
    protected = {"/bin", "/sbin", "/usr/sbin", "/usr/bin"}
    # Remove protected paths from $PATH:
    paths = [p for p in os.environ["PATH"].split(":") if p not in protected]
    # Add temp dir
    bin_dir = mkdtemp()
    paths.insert(0, bin_dir)
    atexit.register(rmtree, bin_dir)
    for directory in protected:
        for file in os.listdir(directory):
            try:
                copy(os.path.join(directory, file), bin_dir)
            except IOError:
                continue
            os.chmod(os.path.join(bin_dir, file), 0o775)
    # Return new $PATH
    return ":".join(paths)


def wait_for_exit(runner, shell_process, processes):
    """Given Popens, wait for one of them to die."""
    while True:
        sleep(0.1)
        if shell_process.poll() is not None:
            # Shell exited, we're done. Automatic shutdown cleanup will kill
            # subprocesses.
            raise SystemExit(shell_process.poll())
        for p in processes:
            code = p.poll()
            if code is not None:
                if sys.stderr.isatty:
                    runner.write(
                        "A subprocess died, killing all processes...\n"
                    )
                killall(processes)
                # Unfortunatly torsocks doesn't deal well with connections
                # being lost, so best we can do is shut down.
                if sys.stderr.isatty:
                    print(
                        "Proxy to Kubernetes exited. This is typically due to"
                        " a lost connection.",
                        file=sys.stderr
                    )
                raise SystemExit(3)


def mount_remote_volumes(runner, remote_info, ssh_port):
    """
    sshfs is used to mount the remote system locally.
    """
    mount_dir = mkdtemp()
    try:
        runner.check_call([
            "sshfs",
            # Private key to use:
            "-o",
            "IdentityFile={}/id_rsa".format(runner.tempdir),
            # Port to use:
            "-p",
            str(ssh_port),
            # Don't validate host key:
            "-o",
            "StrictHostKeyChecking=no",
            # Don't store host key:
            "-o",
            "UserKnownHostsFile=/dev/null",
            "main@localhost:/",
            mount_dir
        ])
        mounted = True
    except CalledProcessError:
        print(
            "Mounting remote volumes failed, they will be unavailable"
            " in this session. This is a known issue when running inside"
            " Docker or on Windows Subystem for Linux. See"
            " https://github.com/datawire/telepresence/issues/115 for"
            " details. If you are not running in those environments"
            " then please report a bug, attaching telepresence.log to"
            " the bug report.",
            file=sys.stderr
        )
        mounted = False
    return mount_dir, mounted


def run_local_command(
    runner, remote_info, args, env_overrides, subprocesses, socks_port,
    ssh_port
):
    """--run-shell/--run support, run command locally."""
    env = os.environ.copy()
    env.update(env_overrides)
    # Create custom torsocks.conf, since some options we want (in particular,
    # port) aren't accessible via env variables in older versions of torconf:
    with NamedTemporaryFile(mode="w+", delete=False) as tor_conffile:
        tor_conffile.write(TORSOCKS_CONFIG.format(socks_port))
    env["TORSOCKS_CONF_FILE"] = tor_conffile.name
    if runner.logfile is not sys.stdout:
        env["TORSOCKS_LOG_FILE_PATH"] = runner.logfile.name
    # Don't use runner.popen() since we want to give program access to current
    # stdout and stderr if it wants it.
    env["PROMPT_COMMAND"] = (
        'PS1="@{}|$PS1";unset PROMPT_COMMAND'.format(
            args.context or
            runner.get_output(["kubectl", "config", "current-context"]).strip()
        )
    )
    # Make sure we use "bash", no "/bin/bash", so we get the copied version on
    # OS X:
    if sys.platform == "darwin":
        env["PATH"] = sip_workaround()
    mount_dir, mounted = mount_remote_volumes(runner, remote_info, ssh_port)
    env["TELEPRESENCE_ROOT"] = mount_dir
    if args.run is None:
        # We skip .bashrc since it might e.g. have kubectl running to get bash
        # autocomplete, and Go programs don't like DYLD on macOS at least (see
        # https://github.com/datawire/telepresence/issues/125).
        command = ["bash", "--norc"]
    else:
        command = args.run
    p = Popen(["torsocks"] + command, env=env)

    def terminate_if_alive():
        runner.write("Shutting down local shell...\n")
        os.remove(tor_conffile.name)
        if p.poll() is None:
            runner.write("Killing local shell...\n")
            p.terminate()
            p.wait()
        if mounted:
            if sys.platform.startswith("linux"):
                runner.get_output(["fusermount", "-u", mount_dir])
            else:
                runner.get_output(["umount", mount_dir])
        os.rmdir(mount_dir)

    atexit.register(terminate_if_alive)
    wait_for_exit(runner, p, subprocesses)


BUG_REPORT_TEMPLATE = u"""\
### What were you trying to do?

(please tell us)

### What did you expect to happen?

(please tell us)

### What happened instead?

(please tell us - the traceback is automatically included, see below)

### Automatically included information

Command line: `{}`
Version: `{}`
Python version: `{}`
kubectl version: `{}`
OS: `{}`
Traceback:

```
{}
```

Logs:

```
{}
```
"""


def require_command(runner, command, message=None):
    if message is None:
        message = "Please install " + command
    try:
        runner.get_output(["which", command])
    except CalledProcessError as e:
        sys.stderr.write(message + "\n")
        sys.stderr.write(
            "See the documentation at http://telepresence.io "
            "for more details.\n"
        )
        raise SystemExit(1)


FEEDBACK_QUESTION = """
Would you like to file an issue with your question?
We'll try to answer quickly, and then improve the documentation going forward.
File an issue: [N/y] """


def ask_for_feedback():
    """Ask user if they want to provide feedback."""
    if input(FEEDBACK_QUESTION) == "y":
        webbrowser.open_new(
            "https://github.com/datawire/telepresence/issues/new"
        )


def main():
    # Make SIGTERM do clean shutdown (in particular, we want atexit functions
    # to be called):
    def shutdown(signum, frame):
        raise SystemExit(0)

    signal.signal(signal.SIGTERM, shutdown)

    try:
        args = parse_args()
    except SystemExit as e:
        if sys.stdin.isatty() and e.code == 0 and sys.argv[1:] in (["-h"],
                                                                   ["--help"]):
            ask_for_feedback()
        raise
    if args.logfile != "-":
        args.logfile = os.path.abspath(args.logfile)

    runner = Runner.open(args.logfile)

    @handle_unexpected_errors(args.logfile)
    def go():
        # Make sure we can access Kubernetes:
        try:
            runner.get_output(["kubectl", "cluster-info"])
        except (CalledProcessError, OSError, IOError) as e:
            sys.stderr.write("Error accessing Kubernetes: {}\n".format(e))
            raise SystemExit(1)
        # Make sure we can run openssh:
        try:
            runner.write("Running 'ssh -V'...")
            version = check_output(["ssh", "-V"], stdin=DEVNULL, stderr=STDOUT)
            if not version.startswith(b"OpenSSH"):
                raise SystemExit(
                    "'ssh' is not the OpenSSH client, apparently."
                )
        except (CalledProcessError, OSError, IOError) as e:
            sys.stderr.write("Error running ssh: {}\n".format(e))
            raise SystemExit(1)
        # Other requirements:
        require_command(
            runner, "torsocks", "Please install torsocks (v2.1 or later)"
        )
        require_command(runner, "sshfs")

        # Write out the private key for accessing remote SSH server:
        with open(runner.tempdir + "/id_rsa", "wb") as f:
            f.write(PRIVATE_RSA_KEY)
        os.chmod(runner.tempdir + "/id_rsa", 0o600)

        # Start the proxy:
        subprocesses, env, socks_port, ssh_port, remote_info = start_proxy(
            runner, args
        )
        # Run the local command:
        run_local_command(
            runner, remote_info, args, env, subprocesses, socks_port, ssh_port
        )

    go()


if __name__ == '__main__':
    main()
