// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.9
// source: connector/connector.proto

package connector

import (
	context "context"
	common "github.com/telepresenceio/telepresence/rpc/v2/common"
	daemon "github.com/telepresenceio/telepresence/rpc/v2/daemon"
	manager "github.com/telepresenceio/telepresence/rpc/v2/manager"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Connector_Version_FullMethodName                 = "/telepresence.connector.Connector/Version"
	Connector_RootDaemonVersion_FullMethodName       = "/telepresence.connector.Connector/RootDaemonVersion"
	Connector_TrafficManagerVersion_FullMethodName   = "/telepresence.connector.Connector/TrafficManagerVersion"
	Connector_AgentImageFQN_FullMethodName           = "/telepresence.connector.Connector/AgentImageFQN"
	Connector_GetIntercept_FullMethodName            = "/telepresence.connector.Connector/GetIntercept"
	Connector_Connect_FullMethodName                 = "/telepresence.connector.Connector/Connect"
	Connector_Disconnect_FullMethodName              = "/telepresence.connector.Connector/Disconnect"
	Connector_GetClusterSubnets_FullMethodName       = "/telepresence.connector.Connector/GetClusterSubnets"
	Connector_Status_FullMethodName                  = "/telepresence.connector.Connector/Status"
	Connector_CanIntercept_FullMethodName            = "/telepresence.connector.Connector/CanIntercept"
	Connector_CreateIntercept_FullMethodName         = "/telepresence.connector.Connector/CreateIntercept"
	Connector_RemoveIntercept_FullMethodName         = "/telepresence.connector.Connector/RemoveIntercept"
	Connector_UpdateIntercept_FullMethodName         = "/telepresence.connector.Connector/UpdateIntercept"
	Connector_Uninstall_FullMethodName               = "/telepresence.connector.Connector/Uninstall"
	Connector_List_FullMethodName                    = "/telepresence.connector.Connector/List"
	Connector_WatchWorkloads_FullMethodName          = "/telepresence.connector.Connector/WatchWorkloads"
	Connector_SetLogLevel_FullMethodName             = "/telepresence.connector.Connector/SetLogLevel"
	Connector_Quit_FullMethodName                    = "/telepresence.connector.Connector/Quit"
	Connector_GatherLogs_FullMethodName              = "/telepresence.connector.Connector/GatherLogs"
	Connector_GatherTraces_FullMethodName            = "/telepresence.connector.Connector/GatherTraces"
	Connector_AddInterceptor_FullMethodName          = "/telepresence.connector.Connector/AddInterceptor"
	Connector_RemoveInterceptor_FullMethodName       = "/telepresence.connector.Connector/RemoveInterceptor"
	Connector_GetNamespaces_FullMethodName           = "/telepresence.connector.Connector/GetNamespaces"
	Connector_RemoteMountAvailability_FullMethodName = "/telepresence.connector.Connector/RemoteMountAvailability"
	Connector_GetConfig_FullMethodName               = "/telepresence.connector.Connector/GetConfig"
	Connector_SetDNSExcludes_FullMethodName          = "/telepresence.connector.Connector/SetDNSExcludes"
	Connector_SetDNSMappings_FullMethodName          = "/telepresence.connector.Connector/SetDNSMappings"
)

// ConnectorClient is the client API for Connector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectorClient interface {
	// Returns version information from the Connector
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	RootDaemonVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// Returns version information from the Traffic Manager
	TrafficManagerVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// Returns the fully qualified image name of the traffic-agent that the agent-injector is configured to inject.
	AgentImageFQN(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.AgentImageFQN, error)
	// GetIntercept gets info from intercept name
	GetIntercept(ctx context.Context, in *manager.GetInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error)
	// Connects to the cluster and connects the laptop's network (via
	// the daemon process) to the cluster's network.  A result code of
	// UNSPECIFIED indicates that the connection was successfully
	// initiated; if already connected, then either ALREADY_CONNECTED or
	// MUST_RESTART is returned, based on whether the current connection
	// is in agreement with the ConnectionRequest.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error)
	// Disconnects the cluster
	Disconnect(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetClusterSubnets gets the outbound info that has been set on daemon
	GetClusterSubnets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterSubnets, error)
	// Status returns the status of the current connection or DISCONNECTED
	// if no connection has been established.
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectInfo, error)
	// Queries the connector whether it is possible to create the given intercept.
	CanIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error)
	// Adds an intercept to a workload.  Requires having already called
	// Connect.
	CreateIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error)
	// Deactivates and removes an existent workload intercept.
	// Requires having already called Connect.
	RemoveIntercept(ctx context.Context, in *manager.RemoveInterceptRequest2, opts ...grpc.CallOption) (*InterceptResult, error)
	UpdateIntercept(ctx context.Context, in *manager.UpdateInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error)
	// Uninstalls traffic-agents from the cluster.
	// Requires having already called Connect.
	Uninstall(ctx context.Context, in *UninstallRequest, opts ...grpc.CallOption) (*common.Result, error)
	// Returns a list of workloads and their current intercept status.
	// Requires having already called Connect.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*WorkloadInfoSnapshot, error)
	// Watch all workloads in the mapped namespaces
	WatchWorkloads(ctx context.Context, in *WatchWorkloadsRequest, opts ...grpc.CallOption) (Connector_WatchWorkloadsClient, error)
	// SetLogLevel will temporarily change the log-level of the traffic-manager, traffic-agent, and user and root daemons.
	SetLogLevel(ctx context.Context, in *LogLevelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Quits (terminates) the connector process.
	Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GatherLogs will acquire logs for the various Telepresence components in kubernetes
	// (pending the request) and return them to the caller
	GatherLogs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogsResponse, error)
	// GatherTraces will acquire traces for the various Telepresence components in kubernetes
	// (pending the request) and save them in a file.
	GatherTraces(ctx context.Context, in *TracesRequest, opts ...grpc.CallOption) (*common.Result, error)
	// AddInterceptor tells the connector that a given process is serving a specific
	// intercept. The connector must kill this process when the intercept ends
	AddInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// RemoveInterceptor removes a previously added interceptor
	RemoveInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetNamespaces gets the mapped namespaces with an optional prefix
	GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*GetNamespacesResponse, error)
	// RemoteMountAvailability checks if remote mounts are possible using the given
	// mount type and returns an error if its not.
	RemoteMountAvailability(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.Result, error)
	// GetConfig returns the current configuration
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClientConfig, error)
	// SetDNSExcludes sets the excludes field of DNSConfig.
	SetDNSExcludes(ctx context.Context, in *daemon.SetDNSExcludesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SetDNSMappings sets the Mappings field of DNSConfig.
	SetDNSMappings(ctx context.Context, in *daemon.SetDNSMappingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type connectorClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectorClient(cc grpc.ClientConnInterface) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, Connector_Version_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RootDaemonVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, Connector_RootDaemonVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) TrafficManagerVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, Connector_TrafficManagerVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) AgentImageFQN(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.AgentImageFQN, error) {
	out := new(manager.AgentImageFQN)
	err := c.cc.Invoke(ctx, Connector_AgentImageFQN_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetIntercept(ctx context.Context, in *manager.GetInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error) {
	out := new(manager.InterceptInfo)
	err := c.cc.Invoke(ctx, Connector_GetIntercept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := c.cc.Invoke(ctx, Connector_Connect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Disconnect(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_Disconnect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetClusterSubnets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterSubnets, error) {
	out := new(ClusterSubnets)
	err := c.cc.Invoke(ctx, Connector_GetClusterSubnets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := c.cc.Invoke(ctx, Connector_Status_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CanIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, Connector_CanIntercept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CreateIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, Connector_CreateIntercept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoveIntercept(ctx context.Context, in *manager.RemoveInterceptRequest2, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, Connector_RemoveIntercept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) UpdateIntercept(ctx context.Context, in *manager.UpdateInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error) {
	out := new(manager.InterceptInfo)
	err := c.cc.Invoke(ctx, Connector_UpdateIntercept_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Uninstall(ctx context.Context, in *UninstallRequest, opts ...grpc.CallOption) (*common.Result, error) {
	out := new(common.Result)
	err := c.cc.Invoke(ctx, Connector_Uninstall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*WorkloadInfoSnapshot, error) {
	out := new(WorkloadInfoSnapshot)
	err := c.cc.Invoke(ctx, Connector_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) WatchWorkloads(ctx context.Context, in *WatchWorkloadsRequest, opts ...grpc.CallOption) (Connector_WatchWorkloadsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Connector_ServiceDesc.Streams[0], Connector_WatchWorkloads_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorWatchWorkloadsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_WatchWorkloadsClient interface {
	Recv() (*WorkloadInfoSnapshot, error)
	grpc.ClientStream
}

type connectorWatchWorkloadsClient struct {
	grpc.ClientStream
}

func (x *connectorWatchWorkloadsClient) Recv() (*WorkloadInfoSnapshot, error) {
	m := new(WorkloadInfoSnapshot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *connectorClient) SetLogLevel(ctx context.Context, in *LogLevelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_SetLogLevel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_Quit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GatherLogs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogsResponse, error) {
	out := new(LogsResponse)
	err := c.cc.Invoke(ctx, Connector_GatherLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GatherTraces(ctx context.Context, in *TracesRequest, opts ...grpc.CallOption) (*common.Result, error) {
	out := new(common.Result)
	err := c.cc.Invoke(ctx, Connector_GatherTraces_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) AddInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_AddInterceptor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoveInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_RemoveInterceptor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*GetNamespacesResponse, error) {
	out := new(GetNamespacesResponse)
	err := c.cc.Invoke(ctx, Connector_GetNamespaces_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoteMountAvailability(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.Result, error) {
	out := new(common.Result)
	err := c.cc.Invoke(ctx, Connector_RemoteMountAvailability_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClientConfig, error) {
	out := new(ClientConfig)
	err := c.cc.Invoke(ctx, Connector_GetConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SetDNSExcludes(ctx context.Context, in *daemon.SetDNSExcludesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_SetDNSExcludes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SetDNSMappings(ctx context.Context, in *daemon.SetDNSMappingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Connector_SetDNSMappings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectorServer is the server API for Connector service.
// All implementations must embed UnimplementedConnectorServer
// for forward compatibility
type ConnectorServer interface {
	// Returns version information from the Connector
	Version(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	RootDaemonVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// Returns version information from the Traffic Manager
	TrafficManagerVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// Returns the fully qualified image name of the traffic-agent that the agent-injector is configured to inject.
	AgentImageFQN(context.Context, *emptypb.Empty) (*manager.AgentImageFQN, error)
	// GetIntercept gets info from intercept name
	GetIntercept(context.Context, *manager.GetInterceptRequest) (*manager.InterceptInfo, error)
	// Connects to the cluster and connects the laptop's network (via
	// the daemon process) to the cluster's network.  A result code of
	// UNSPECIFIED indicates that the connection was successfully
	// initiated; if already connected, then either ALREADY_CONNECTED or
	// MUST_RESTART is returned, based on whether the current connection
	// is in agreement with the ConnectionRequest.
	Connect(context.Context, *ConnectRequest) (*ConnectInfo, error)
	// Disconnects the cluster
	Disconnect(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetClusterSubnets gets the outbound info that has been set on daemon
	GetClusterSubnets(context.Context, *emptypb.Empty) (*ClusterSubnets, error)
	// Status returns the status of the current connection or DISCONNECTED
	// if no connection has been established.
	Status(context.Context, *emptypb.Empty) (*ConnectInfo, error)
	// Queries the connector whether it is possible to create the given intercept.
	CanIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error)
	// Adds an intercept to a workload.  Requires having already called
	// Connect.
	CreateIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error)
	// Deactivates and removes an existent workload intercept.
	// Requires having already called Connect.
	RemoveIntercept(context.Context, *manager.RemoveInterceptRequest2) (*InterceptResult, error)
	UpdateIntercept(context.Context, *manager.UpdateInterceptRequest) (*manager.InterceptInfo, error)
	// Uninstalls traffic-agents from the cluster.
	// Requires having already called Connect.
	Uninstall(context.Context, *UninstallRequest) (*common.Result, error)
	// Returns a list of workloads and their current intercept status.
	// Requires having already called Connect.
	List(context.Context, *ListRequest) (*WorkloadInfoSnapshot, error)
	// Watch all workloads in the mapped namespaces
	WatchWorkloads(*WatchWorkloadsRequest, Connector_WatchWorkloadsServer) error
	// SetLogLevel will temporarily change the log-level of the traffic-manager, traffic-agent, and user and root daemons.
	SetLogLevel(context.Context, *LogLevelRequest) (*emptypb.Empty, error)
	// Quits (terminates) the connector process.
	Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GatherLogs will acquire logs for the various Telepresence components in kubernetes
	// (pending the request) and return them to the caller
	GatherLogs(context.Context, *LogsRequest) (*LogsResponse, error)
	// GatherTraces will acquire traces for the various Telepresence components in kubernetes
	// (pending the request) and save them in a file.
	GatherTraces(context.Context, *TracesRequest) (*common.Result, error)
	// AddInterceptor tells the connector that a given process is serving a specific
	// intercept. The connector must kill this process when the intercept ends
	AddInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error)
	// RemoveInterceptor removes a previously added interceptor
	RemoveInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error)
	// GetNamespaces gets the mapped namespaces with an optional prefix
	GetNamespaces(context.Context, *GetNamespacesRequest) (*GetNamespacesResponse, error)
	// RemoteMountAvailability checks if remote mounts are possible using the given
	// mount type and returns an error if its not.
	RemoteMountAvailability(context.Context, *emptypb.Empty) (*common.Result, error)
	// GetConfig returns the current configuration
	GetConfig(context.Context, *emptypb.Empty) (*ClientConfig, error)
	// SetDNSExcludes sets the excludes field of DNSConfig.
	SetDNSExcludes(context.Context, *daemon.SetDNSExcludesRequest) (*emptypb.Empty, error)
	// SetDNSMappings sets the Mappings field of DNSConfig.
	SetDNSMappings(context.Context, *daemon.SetDNSMappingsRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedConnectorServer()
}

// UnimplementedConnectorServer must be embedded to have forward compatible implementations.
type UnimplementedConnectorServer struct {
}

func (UnimplementedConnectorServer) Version(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedConnectorServer) RootDaemonVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RootDaemonVersion not implemented")
}
func (UnimplementedConnectorServer) TrafficManagerVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficManagerVersion not implemented")
}
func (UnimplementedConnectorServer) AgentImageFQN(context.Context, *emptypb.Empty) (*manager.AgentImageFQN, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AgentImageFQN not implemented")
}
func (UnimplementedConnectorServer) GetIntercept(context.Context, *manager.GetInterceptRequest) (*manager.InterceptInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntercept not implemented")
}
func (UnimplementedConnectorServer) Connect(context.Context, *ConnectRequest) (*ConnectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedConnectorServer) Disconnect(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedConnectorServer) GetClusterSubnets(context.Context, *emptypb.Empty) (*ClusterSubnets, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterSubnets not implemented")
}
func (UnimplementedConnectorServer) Status(context.Context, *emptypb.Empty) (*ConnectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedConnectorServer) CanIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanIntercept not implemented")
}
func (UnimplementedConnectorServer) CreateIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIntercept not implemented")
}
func (UnimplementedConnectorServer) RemoveIntercept(context.Context, *manager.RemoveInterceptRequest2) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveIntercept not implemented")
}
func (UnimplementedConnectorServer) UpdateIntercept(context.Context, *manager.UpdateInterceptRequest) (*manager.InterceptInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIntercept not implemented")
}
func (UnimplementedConnectorServer) Uninstall(context.Context, *UninstallRequest) (*common.Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uninstall not implemented")
}
func (UnimplementedConnectorServer) List(context.Context, *ListRequest) (*WorkloadInfoSnapshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedConnectorServer) WatchWorkloads(*WatchWorkloadsRequest, Connector_WatchWorkloadsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchWorkloads not implemented")
}
func (UnimplementedConnectorServer) SetLogLevel(context.Context, *LogLevelRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogLevel not implemented")
}
func (UnimplementedConnectorServer) Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quit not implemented")
}
func (UnimplementedConnectorServer) GatherLogs(context.Context, *LogsRequest) (*LogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatherLogs not implemented")
}
func (UnimplementedConnectorServer) GatherTraces(context.Context, *TracesRequest) (*common.Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatherTraces not implemented")
}
func (UnimplementedConnectorServer) AddInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInterceptor not implemented")
}
func (UnimplementedConnectorServer) RemoveInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInterceptor not implemented")
}
func (UnimplementedConnectorServer) GetNamespaces(context.Context, *GetNamespacesRequest) (*GetNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespaces not implemented")
}
func (UnimplementedConnectorServer) RemoteMountAvailability(context.Context, *emptypb.Empty) (*common.Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteMountAvailability not implemented")
}
func (UnimplementedConnectorServer) GetConfig(context.Context, *emptypb.Empty) (*ClientConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedConnectorServer) SetDNSExcludes(context.Context, *daemon.SetDNSExcludesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDNSExcludes not implemented")
}
func (UnimplementedConnectorServer) SetDNSMappings(context.Context, *daemon.SetDNSMappingsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDNSMappings not implemented")
}
func (UnimplementedConnectorServer) mustEmbedUnimplementedConnectorServer() {}

// UnsafeConnectorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectorServer will
// result in compilation errors.
type UnsafeConnectorServer interface {
	mustEmbedUnimplementedConnectorServer()
}

func RegisterConnectorServer(s grpc.ServiceRegistrar, srv ConnectorServer) {
	s.RegisterService(&Connector_ServiceDesc, srv)
}

func _Connector_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RootDaemonVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RootDaemonVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_RootDaemonVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RootDaemonVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_TrafficManagerVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).TrafficManagerVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_TrafficManagerVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).TrafficManagerVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_AgentImageFQN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).AgentImageFQN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_AgentImageFQN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).AgentImageFQN(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.GetInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GetIntercept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetIntercept(ctx, req.(*manager.GetInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Disconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Disconnect(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetClusterSubnets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetClusterSubnets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GetClusterSubnets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetClusterSubnets(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CanIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CanIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_CanIntercept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CanIntercept(ctx, req.(*CreateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CreateIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_CreateIntercept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateIntercept(ctx, req.(*CreateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoveIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.RemoveInterceptRequest2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoveIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_RemoveIntercept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoveIntercept(ctx, req.(*manager.RemoveInterceptRequest2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_UpdateIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.UpdateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).UpdateIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_UpdateIntercept_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).UpdateIntercept(ctx, req.(*manager.UpdateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Uninstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UninstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Uninstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Uninstall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Uninstall(ctx, req.(*UninstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_WatchWorkloads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchWorkloadsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).WatchWorkloads(m, &connectorWatchWorkloadsServer{stream})
}

type Connector_WatchWorkloadsServer interface {
	Send(*WorkloadInfoSnapshot) error
	grpc.ServerStream
}

type connectorWatchWorkloadsServer struct {
	grpc.ServerStream
}

func (x *connectorWatchWorkloadsServer) Send(m *WorkloadInfoSnapshot) error {
	return x.ServerStream.SendMsg(m)
}

func _Connector_SetLogLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SetLogLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_SetLogLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SetLogLevel(ctx, req.(*LogLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Quit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Quit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_Quit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Quit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GatherLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GatherLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GatherLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GatherLogs(ctx, req.(*LogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GatherTraces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TracesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GatherTraces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GatherTraces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GatherTraces(ctx, req.(*TracesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_AddInterceptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interceptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).AddInterceptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_AddInterceptor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).AddInterceptor(ctx, req.(*Interceptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoveInterceptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interceptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoveInterceptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_RemoveInterceptor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoveInterceptor(ctx, req.(*Interceptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GetNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetNamespaces(ctx, req.(*GetNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoteMountAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoteMountAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_RemoteMountAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoteMountAvailability(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SetDNSExcludes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(daemon.SetDNSExcludesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SetDNSExcludes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_SetDNSExcludes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SetDNSExcludes(ctx, req.(*daemon.SetDNSExcludesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SetDNSMappings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(daemon.SetDNSMappingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SetDNSMappings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Connector_SetDNSMappings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SetDNSMappings(ctx, req.(*daemon.SetDNSMappingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Connector_ServiceDesc is the grpc.ServiceDesc for Connector service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Connector_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "telepresence.connector.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Connector_Version_Handler,
		},
		{
			MethodName: "RootDaemonVersion",
			Handler:    _Connector_RootDaemonVersion_Handler,
		},
		{
			MethodName: "TrafficManagerVersion",
			Handler:    _Connector_TrafficManagerVersion_Handler,
		},
		{
			MethodName: "AgentImageFQN",
			Handler:    _Connector_AgentImageFQN_Handler,
		},
		{
			MethodName: "GetIntercept",
			Handler:    _Connector_GetIntercept_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Connector_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Connector_Disconnect_Handler,
		},
		{
			MethodName: "GetClusterSubnets",
			Handler:    _Connector_GetClusterSubnets_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Connector_Status_Handler,
		},
		{
			MethodName: "CanIntercept",
			Handler:    _Connector_CanIntercept_Handler,
		},
		{
			MethodName: "CreateIntercept",
			Handler:    _Connector_CreateIntercept_Handler,
		},
		{
			MethodName: "RemoveIntercept",
			Handler:    _Connector_RemoveIntercept_Handler,
		},
		{
			MethodName: "UpdateIntercept",
			Handler:    _Connector_UpdateIntercept_Handler,
		},
		{
			MethodName: "Uninstall",
			Handler:    _Connector_Uninstall_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Connector_List_Handler,
		},
		{
			MethodName: "SetLogLevel",
			Handler:    _Connector_SetLogLevel_Handler,
		},
		{
			MethodName: "Quit",
			Handler:    _Connector_Quit_Handler,
		},
		{
			MethodName: "GatherLogs",
			Handler:    _Connector_GatherLogs_Handler,
		},
		{
			MethodName: "GatherTraces",
			Handler:    _Connector_GatherTraces_Handler,
		},
		{
			MethodName: "AddInterceptor",
			Handler:    _Connector_AddInterceptor_Handler,
		},
		{
			MethodName: "RemoveInterceptor",
			Handler:    _Connector_RemoveInterceptor_Handler,
		},
		{
			MethodName: "GetNamespaces",
			Handler:    _Connector_GetNamespaces_Handler,
		},
		{
			MethodName: "RemoteMountAvailability",
			Handler:    _Connector_RemoteMountAvailability_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Connector_GetConfig_Handler,
		},
		{
			MethodName: "SetDNSExcludes",
			Handler:    _Connector_SetDNSExcludes_Handler,
		},
		{
			MethodName: "SetDNSMappings",
			Handler:    _Connector_SetDNSMappings_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchWorkloads",
			Handler:       _Connector_WatchWorkloads_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "connector/connector.proto",
}

const (
	ManagerProxy_Version_FullMethodName          = "/telepresence.connector.ManagerProxy/Version"
	ManagerProxy_GetClientConfig_FullMethodName  = "/telepresence.connector.ManagerProxy/GetClientConfig"
	ManagerProxy_EnsureAgent_FullMethodName      = "/telepresence.connector.ManagerProxy/EnsureAgent"
	ManagerProxy_WatchClusterInfo_FullMethodName = "/telepresence.connector.ManagerProxy/WatchClusterInfo"
	ManagerProxy_LookupDNS_FullMethodName        = "/telepresence.connector.ManagerProxy/LookupDNS"
	ManagerProxy_Tunnel_FullMethodName           = "/telepresence.connector.ManagerProxy/Tunnel"
)

// ManagerProxyClient is the client API for ManagerProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerProxyClient interface {
	// Version returns the version information of the Manager.
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.VersionInfo2, error)
	// GetClientConfig returns the config that connected clients should use for this manager.
	GetClientConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.CLIConfig, error)
	// EnsureAgent ensures that an agent is injected to the pods of a workload
	EnsureAgent(ctx context.Context, in *manager.EnsureAgentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// WatchClusterInfo returns information needed when establishing
	// connectivity to the cluster.
	WatchClusterInfo(ctx context.Context, in *manager.SessionInfo, opts ...grpc.CallOption) (ManagerProxy_WatchClusterInfoClient, error)
	// LookupDNS performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	LookupDNS(ctx context.Context, in *manager.DNSRequest, opts ...grpc.CallOption) (*manager.DNSResponse, error)
	// A Tunnel represents one single connection where the client or
	// traffic-agent represents one end (the client-side) and the
	// traffic-manager represents the other (the server side). The first
	// message that a client sends when the tunnel is established is will
	// always contain the session ID, connection ID, and timeouts used by
	// the dialer endpoints.
	Tunnel(ctx context.Context, opts ...grpc.CallOption) (ManagerProxy_TunnelClient, error)
}

type managerProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerProxyClient(cc grpc.ClientConnInterface) ManagerProxyClient {
	return &managerProxyClient{cc}
}

func (c *managerProxyClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.VersionInfo2, error) {
	out := new(manager.VersionInfo2)
	err := c.cc.Invoke(ctx, ManagerProxy_Version_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) GetClientConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.CLIConfig, error) {
	out := new(manager.CLIConfig)
	err := c.cc.Invoke(ctx, ManagerProxy_GetClientConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) EnsureAgent(ctx context.Context, in *manager.EnsureAgentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ManagerProxy_EnsureAgent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) WatchClusterInfo(ctx context.Context, in *manager.SessionInfo, opts ...grpc.CallOption) (ManagerProxy_WatchClusterInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerProxy_ServiceDesc.Streams[0], ManagerProxy_WatchClusterInfo_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &managerProxyWatchClusterInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerProxy_WatchClusterInfoClient interface {
	Recv() (*manager.ClusterInfo, error)
	grpc.ClientStream
}

type managerProxyWatchClusterInfoClient struct {
	grpc.ClientStream
}

func (x *managerProxyWatchClusterInfoClient) Recv() (*manager.ClusterInfo, error) {
	m := new(manager.ClusterInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerProxyClient) LookupDNS(ctx context.Context, in *manager.DNSRequest, opts ...grpc.CallOption) (*manager.DNSResponse, error) {
	out := new(manager.DNSResponse)
	err := c.cc.Invoke(ctx, ManagerProxy_LookupDNS_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) Tunnel(ctx context.Context, opts ...grpc.CallOption) (ManagerProxy_TunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerProxy_ServiceDesc.Streams[1], ManagerProxy_Tunnel_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &managerProxyTunnelClient{stream}
	return x, nil
}

type ManagerProxy_TunnelClient interface {
	Send(*manager.TunnelMessage) error
	Recv() (*manager.TunnelMessage, error)
	grpc.ClientStream
}

type managerProxyTunnelClient struct {
	grpc.ClientStream
}

func (x *managerProxyTunnelClient) Send(m *manager.TunnelMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *managerProxyTunnelClient) Recv() (*manager.TunnelMessage, error) {
	m := new(manager.TunnelMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ManagerProxyServer is the server API for ManagerProxy service.
// All implementations must embed UnimplementedManagerProxyServer
// for forward compatibility
type ManagerProxyServer interface {
	// Version returns the version information of the Manager.
	Version(context.Context, *emptypb.Empty) (*manager.VersionInfo2, error)
	// GetClientConfig returns the config that connected clients should use for this manager.
	GetClientConfig(context.Context, *emptypb.Empty) (*manager.CLIConfig, error)
	// EnsureAgent ensures that an agent is injected to the pods of a workload
	EnsureAgent(context.Context, *manager.EnsureAgentRequest) (*emptypb.Empty, error)
	// WatchClusterInfo returns information needed when establishing
	// connectivity to the cluster.
	WatchClusterInfo(*manager.SessionInfo, ManagerProxy_WatchClusterInfoServer) error
	// LookupDNS performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	LookupDNS(context.Context, *manager.DNSRequest) (*manager.DNSResponse, error)
	// A Tunnel represents one single connection where the client or
	// traffic-agent represents one end (the client-side) and the
	// traffic-manager represents the other (the server side). The first
	// message that a client sends when the tunnel is established is will
	// always contain the session ID, connection ID, and timeouts used by
	// the dialer endpoints.
	Tunnel(ManagerProxy_TunnelServer) error
	mustEmbedUnimplementedManagerProxyServer()
}

// UnimplementedManagerProxyServer must be embedded to have forward compatible implementations.
type UnimplementedManagerProxyServer struct {
}

func (UnimplementedManagerProxyServer) Version(context.Context, *emptypb.Empty) (*manager.VersionInfo2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedManagerProxyServer) GetClientConfig(context.Context, *emptypb.Empty) (*manager.CLIConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClientConfig not implemented")
}
func (UnimplementedManagerProxyServer) EnsureAgent(context.Context, *manager.EnsureAgentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureAgent not implemented")
}
func (UnimplementedManagerProxyServer) WatchClusterInfo(*manager.SessionInfo, ManagerProxy_WatchClusterInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchClusterInfo not implemented")
}
func (UnimplementedManagerProxyServer) LookupDNS(context.Context, *manager.DNSRequest) (*manager.DNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupDNS not implemented")
}
func (UnimplementedManagerProxyServer) Tunnel(ManagerProxy_TunnelServer) error {
	return status.Errorf(codes.Unimplemented, "method Tunnel not implemented")
}
func (UnimplementedManagerProxyServer) mustEmbedUnimplementedManagerProxyServer() {}

// UnsafeManagerProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerProxyServer will
// result in compilation errors.
type UnsafeManagerProxyServer interface {
	mustEmbedUnimplementedManagerProxyServer()
}

func RegisterManagerProxyServer(s grpc.ServiceRegistrar, srv ManagerProxyServer) {
	s.RegisterService(&ManagerProxy_ServiceDesc, srv)
}

func _ManagerProxy_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagerProxy_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_GetClientConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).GetClientConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagerProxy_GetClientConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).GetClientConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_EnsureAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.EnsureAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).EnsureAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagerProxy_EnsureAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).EnsureAgent(ctx, req.(*manager.EnsureAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_WatchClusterInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(manager.SessionInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerProxyServer).WatchClusterInfo(m, &managerProxyWatchClusterInfoServer{stream})
}

type ManagerProxy_WatchClusterInfoServer interface {
	Send(*manager.ClusterInfo) error
	grpc.ServerStream
}

type managerProxyWatchClusterInfoServer struct {
	grpc.ServerStream
}

func (x *managerProxyWatchClusterInfoServer) Send(m *manager.ClusterInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerProxy_LookupDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.DNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).LookupDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ManagerProxy_LookupDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).LookupDNS(ctx, req.(*manager.DNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_Tunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ManagerProxyServer).Tunnel(&managerProxyTunnelServer{stream})
}

type ManagerProxy_TunnelServer interface {
	Send(*manager.TunnelMessage) error
	Recv() (*manager.TunnelMessage, error)
	grpc.ServerStream
}

type managerProxyTunnelServer struct {
	grpc.ServerStream
}

func (x *managerProxyTunnelServer) Send(m *manager.TunnelMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *managerProxyTunnelServer) Recv() (*manager.TunnelMessage, error) {
	m := new(manager.TunnelMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ManagerProxy_ServiceDesc is the grpc.ServiceDesc for ManagerProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagerProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "telepresence.connector.ManagerProxy",
	HandlerType: (*ManagerProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _ManagerProxy_Version_Handler,
		},
		{
			MethodName: "GetClientConfig",
			Handler:    _ManagerProxy_GetClientConfig_Handler,
		},
		{
			MethodName: "EnsureAgent",
			Handler:    _ManagerProxy_EnsureAgent_Handler,
		},
		{
			MethodName: "LookupDNS",
			Handler:    _ManagerProxy_LookupDNS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchClusterInfo",
			Handler:       _ManagerProxy_WatchClusterInfo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Tunnel",
			Handler:       _ManagerProxy_Tunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "connector/connector.proto",
}
