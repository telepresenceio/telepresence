// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: connector/connector.proto

package connector

import (
	context "context"
	common "github.com/telepresenceio/telepresence/rpc/v2/common"
	manager "github.com/telepresenceio/telepresence/rpc/v2/manager"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ConnectorClient is the client API for Connector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectorClient interface {
	// Returns version information from the Connector
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	RootDaemonVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	TrafficManagerVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error)
	// GetIntercept gets info from intercept name
	GetIntercept(ctx context.Context, in *manager.GetInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error)
	// Connects to the cluster and connects the laptop's network (via
	// the daemon process) to the cluster's network.  A result code of
	// UNSPECIFIED indicates that the connection was successfully
	// initiated; if already connected, then either ALREADY_CONNECTED or
	// MUST_RESTART is returned, based on whether the current connection
	// is in agreement with the ConnectionRequest.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error)
	// Disconnects the cluster
	Disconnect(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetClusterSubnets gets the outbound info that has been set on daemon
	GetClusterSubnets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterSubnets, error)
	// Status returns the status of the current connection or DISCONNECTED
	// if no connection has been established.
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectInfo, error)
	// Queries the connector whether it is possible to create the given intercept.
	CanIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error)
	// Adds an intercept to a workload.  Requires having already called
	// Connect.
	CreateIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error)
	// Deactivates and removes an existent workload intercept.
	// Requires having already called Connect.
	RemoveIntercept(ctx context.Context, in *manager.RemoveInterceptRequest2, opts ...grpc.CallOption) (*InterceptResult, error)
	UpdateIntercept(ctx context.Context, in *manager.UpdateInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error)
	// Installs, Upgrades, or Uninstalls the traffic-manager in the cluster.
	Helm(ctx context.Context, in *HelmRequest, opts ...grpc.CallOption) (*Result, error)
	// Uninstalls traffic-agents from the cluster.
	// Requires having already called Connect.
	Uninstall(ctx context.Context, in *UninstallRequest, opts ...grpc.CallOption) (*Result, error)
	// Returns a list of workloads and their current intercept status.
	// Requires having already called Connect.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*WorkloadInfoSnapshot, error)
	// Watch all workloads in the mapped namespaces
	WatchWorkloads(ctx context.Context, in *WatchWorkloadsRequest, opts ...grpc.CallOption) (Connector_WatchWorkloadsClient, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResult, error)
	// Returns an error with code=NotFound if not currently logged in.
	Logout(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetCloudUserInfo(ctx context.Context, in *UserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error)
	GetCloudAPIKey(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyData, error)
	GetCloudLicense(ctx context.Context, in *LicenseRequest, opts ...grpc.CallOption) (*LicenseData, error)
	// SetLogLevel will temporarily change the log-level of the traffic-manager, traffic-agent, and user and root daemons.
	SetLogLevel(ctx context.Context, in *LogLevelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Quits (terminates) the connector process.
	Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GatherLogs will acquire logs for the various Telepresence components in kubernetes
	// (pending the request) and return them to the caller
	GatherLogs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogsResponse, error)
	// GatherTraces will acquire traces for the various Telepresence components in kubernetes
	// (pending the request) and save them in a file.
	GatherTraces(ctx context.Context, in *TracesRequest, opts ...grpc.CallOption) (*Result, error)
	// AddInterceptor tells the connector that a given process is serving a specific
	// intercept. The connector must kill this process when the intercept ends
	AddInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// RemoveInterceptor removes a previously added interceptor
	RemoveInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetNamespaces gets the mapped namespaces with an optional prefix
	GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*GetNamespacesResponse, error)
	// RemoteMountAvailability checks if remote mounts are possible using the given
	// mount type and returns an error if its not.
	RemoteMountAvailability(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error)
	// GetConfig returns the current configuration
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClientConfig, error)
}

type connectorClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectorClient(cc grpc.ClientConnInterface) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RootDaemonVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/RootDaemonVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) TrafficManagerVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*common.VersionInfo, error) {
	out := new(common.VersionInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/TrafficManagerVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetIntercept(ctx context.Context, in *manager.GetInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error) {
	out := new(manager.InterceptInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetIntercept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Disconnect(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetClusterSubnets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterSubnets, error) {
	out := new(ClusterSubnets)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetClusterSubnets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CanIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/CanIntercept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CreateIntercept(ctx context.Context, in *CreateInterceptRequest, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/CreateIntercept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoveIntercept(ctx context.Context, in *manager.RemoveInterceptRequest2, opts ...grpc.CallOption) (*InterceptResult, error) {
	out := new(InterceptResult)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/RemoveIntercept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) UpdateIntercept(ctx context.Context, in *manager.UpdateInterceptRequest, opts ...grpc.CallOption) (*manager.InterceptInfo, error) {
	out := new(manager.InterceptInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/UpdateIntercept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Helm(ctx context.Context, in *HelmRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Helm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Uninstall(ctx context.Context, in *UninstallRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Uninstall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*WorkloadInfoSnapshot, error) {
	out := new(WorkloadInfoSnapshot)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) WatchWorkloads(ctx context.Context, in *WatchWorkloadsRequest, opts ...grpc.CallOption) (Connector_WatchWorkloadsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Connector_ServiceDesc.Streams[0], "/telepresence.connector.Connector/WatchWorkloads", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorWatchWorkloadsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_WatchWorkloadsClient interface {
	Recv() (*WorkloadInfoSnapshot, error)
	grpc.ClientStream
}

type connectorWatchWorkloadsClient struct {
	grpc.ClientStream
}

func (x *connectorWatchWorkloadsClient) Recv() (*WorkloadInfoSnapshot, error) {
	m := new(WorkloadInfoSnapshot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *connectorClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResult, error) {
	out := new(LoginResult)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Logout(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetCloudUserInfo(ctx context.Context, in *UserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetCloudUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetCloudAPIKey(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyData, error) {
	out := new(KeyData)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetCloudAPIKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetCloudLicense(ctx context.Context, in *LicenseRequest, opts ...grpc.CallOption) (*LicenseData, error) {
	out := new(LicenseData)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetCloudLicense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SetLogLevel(ctx context.Context, in *LogLevelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/SetLogLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/Quit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GatherLogs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogsResponse, error) {
	out := new(LogsResponse)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GatherLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GatherTraces(ctx context.Context, in *TracesRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GatherTraces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) AddInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/AddInterceptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoveInterceptor(ctx context.Context, in *Interceptor, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/RemoveInterceptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*GetNamespacesResponse, error) {
	out := new(GetNamespacesResponse)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) RemoteMountAvailability(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/RemoteMountAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClientConfig, error) {
	out := new(ClientConfig)
	err := c.cc.Invoke(ctx, "/telepresence.connector.Connector/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectorServer is the server API for Connector service.
// All implementations must embed UnimplementedConnectorServer
// for forward compatibility
type ConnectorServer interface {
	// Returns version information from the Connector
	Version(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	RootDaemonVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// Returns version information from the Root Daemon
	TrafficManagerVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error)
	// GetIntercept gets info from intercept name
	GetIntercept(context.Context, *manager.GetInterceptRequest) (*manager.InterceptInfo, error)
	// Connects to the cluster and connects the laptop's network (via
	// the daemon process) to the cluster's network.  A result code of
	// UNSPECIFIED indicates that the connection was successfully
	// initiated; if already connected, then either ALREADY_CONNECTED or
	// MUST_RESTART is returned, based on whether the current connection
	// is in agreement with the ConnectionRequest.
	Connect(context.Context, *ConnectRequest) (*ConnectInfo, error)
	// Disconnects the cluster
	Disconnect(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetClusterSubnets gets the outbound info that has been set on daemon
	GetClusterSubnets(context.Context, *emptypb.Empty) (*ClusterSubnets, error)
	// Status returns the status of the current connection or DISCONNECTED
	// if no connection has been established.
	Status(context.Context, *emptypb.Empty) (*ConnectInfo, error)
	// Queries the connector whether it is possible to create the given intercept.
	CanIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error)
	// Adds an intercept to a workload.  Requires having already called
	// Connect.
	CreateIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error)
	// Deactivates and removes an existent workload intercept.
	// Requires having already called Connect.
	RemoveIntercept(context.Context, *manager.RemoveInterceptRequest2) (*InterceptResult, error)
	UpdateIntercept(context.Context, *manager.UpdateInterceptRequest) (*manager.InterceptInfo, error)
	// Installs, Upgrades, or Uninstalls the traffic-manager in the cluster.
	Helm(context.Context, *HelmRequest) (*Result, error)
	// Uninstalls traffic-agents from the cluster.
	// Requires having already called Connect.
	Uninstall(context.Context, *UninstallRequest) (*Result, error)
	// Returns a list of workloads and their current intercept status.
	// Requires having already called Connect.
	List(context.Context, *ListRequest) (*WorkloadInfoSnapshot, error)
	// Watch all workloads in the mapped namespaces
	WatchWorkloads(*WatchWorkloadsRequest, Connector_WatchWorkloadsServer) error
	Login(context.Context, *LoginRequest) (*LoginResult, error)
	// Returns an error with code=NotFound if not currently logged in.
	Logout(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	GetCloudUserInfo(context.Context, *UserInfoRequest) (*UserInfo, error)
	GetCloudAPIKey(context.Context, *KeyRequest) (*KeyData, error)
	GetCloudLicense(context.Context, *LicenseRequest) (*LicenseData, error)
	// SetLogLevel will temporarily change the log-level of the traffic-manager, traffic-agent, and user and root daemons.
	SetLogLevel(context.Context, *LogLevelRequest) (*emptypb.Empty, error)
	// Quits (terminates) the connector process.
	Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GatherLogs will acquire logs for the various Telepresence components in kubernetes
	// (pending the request) and return them to the caller
	GatherLogs(context.Context, *LogsRequest) (*LogsResponse, error)
	// GatherTraces will acquire traces for the various Telepresence components in kubernetes
	// (pending the request) and save them in a file.
	GatherTraces(context.Context, *TracesRequest) (*Result, error)
	// AddInterceptor tells the connector that a given process is serving a specific
	// intercept. The connector must kill this process when the intercept ends
	AddInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error)
	// RemoveInterceptor removes a previously added interceptor
	RemoveInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error)
	// GetNamespaces gets the mapped namespaces with an optional prefix
	GetNamespaces(context.Context, *GetNamespacesRequest) (*GetNamespacesResponse, error)
	// RemoteMountAvailability checks if remote mounts are possible using the given
	// mount type and returns an error if its not.
	RemoteMountAvailability(context.Context, *emptypb.Empty) (*Result, error)
	// GetConfig returns the current configuration
	GetConfig(context.Context, *emptypb.Empty) (*ClientConfig, error)
	mustEmbedUnimplementedConnectorServer()
}

// UnimplementedConnectorServer must be embedded to have forward compatible implementations.
type UnimplementedConnectorServer struct {
}

func (UnimplementedConnectorServer) Version(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedConnectorServer) RootDaemonVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RootDaemonVersion not implemented")
}
func (UnimplementedConnectorServer) TrafficManagerVersion(context.Context, *emptypb.Empty) (*common.VersionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficManagerVersion not implemented")
}
func (UnimplementedConnectorServer) GetIntercept(context.Context, *manager.GetInterceptRequest) (*manager.InterceptInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntercept not implemented")
}
func (UnimplementedConnectorServer) Connect(context.Context, *ConnectRequest) (*ConnectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedConnectorServer) Disconnect(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedConnectorServer) GetClusterSubnets(context.Context, *emptypb.Empty) (*ClusterSubnets, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterSubnets not implemented")
}
func (UnimplementedConnectorServer) Status(context.Context, *emptypb.Empty) (*ConnectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedConnectorServer) CanIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanIntercept not implemented")
}
func (UnimplementedConnectorServer) CreateIntercept(context.Context, *CreateInterceptRequest) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIntercept not implemented")
}
func (UnimplementedConnectorServer) RemoveIntercept(context.Context, *manager.RemoveInterceptRequest2) (*InterceptResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveIntercept not implemented")
}
func (UnimplementedConnectorServer) UpdateIntercept(context.Context, *manager.UpdateInterceptRequest) (*manager.InterceptInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIntercept not implemented")
}
func (UnimplementedConnectorServer) Helm(context.Context, *HelmRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Helm not implemented")
}
func (UnimplementedConnectorServer) Uninstall(context.Context, *UninstallRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uninstall not implemented")
}
func (UnimplementedConnectorServer) List(context.Context, *ListRequest) (*WorkloadInfoSnapshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedConnectorServer) WatchWorkloads(*WatchWorkloadsRequest, Connector_WatchWorkloadsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchWorkloads not implemented")
}
func (UnimplementedConnectorServer) Login(context.Context, *LoginRequest) (*LoginResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedConnectorServer) Logout(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedConnectorServer) GetCloudUserInfo(context.Context, *UserInfoRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudUserInfo not implemented")
}
func (UnimplementedConnectorServer) GetCloudAPIKey(context.Context, *KeyRequest) (*KeyData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudAPIKey not implemented")
}
func (UnimplementedConnectorServer) GetCloudLicense(context.Context, *LicenseRequest) (*LicenseData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudLicense not implemented")
}
func (UnimplementedConnectorServer) SetLogLevel(context.Context, *LogLevelRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogLevel not implemented")
}
func (UnimplementedConnectorServer) Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quit not implemented")
}
func (UnimplementedConnectorServer) GatherLogs(context.Context, *LogsRequest) (*LogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatherLogs not implemented")
}
func (UnimplementedConnectorServer) GatherTraces(context.Context, *TracesRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatherTraces not implemented")
}
func (UnimplementedConnectorServer) AddInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInterceptor not implemented")
}
func (UnimplementedConnectorServer) RemoveInterceptor(context.Context, *Interceptor) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInterceptor not implemented")
}
func (UnimplementedConnectorServer) GetNamespaces(context.Context, *GetNamespacesRequest) (*GetNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespaces not implemented")
}
func (UnimplementedConnectorServer) RemoteMountAvailability(context.Context, *emptypb.Empty) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteMountAvailability not implemented")
}
func (UnimplementedConnectorServer) GetConfig(context.Context, *emptypb.Empty) (*ClientConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedConnectorServer) mustEmbedUnimplementedConnectorServer() {}

// UnsafeConnectorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectorServer will
// result in compilation errors.
type UnsafeConnectorServer interface {
	mustEmbedUnimplementedConnectorServer()
}

func RegisterConnectorServer(s grpc.ServiceRegistrar, srv ConnectorServer) {
	s.RegisterService(&Connector_ServiceDesc, srv)
}

func _Connector_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RootDaemonVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RootDaemonVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/RootDaemonVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RootDaemonVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_TrafficManagerVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).TrafficManagerVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/TrafficManagerVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).TrafficManagerVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.GetInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetIntercept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetIntercept(ctx, req.(*manager.GetInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Disconnect(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetClusterSubnets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetClusterSubnets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetClusterSubnets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetClusterSubnets(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CanIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CanIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/CanIntercept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CanIntercept(ctx, req.(*CreateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CreateIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/CreateIntercept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateIntercept(ctx, req.(*CreateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoveIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.RemoveInterceptRequest2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoveIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/RemoveIntercept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoveIntercept(ctx, req.(*manager.RemoveInterceptRequest2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_UpdateIntercept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.UpdateInterceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).UpdateIntercept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/UpdateIntercept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).UpdateIntercept(ctx, req.(*manager.UpdateInterceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Helm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Helm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Helm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Helm(ctx, req.(*HelmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Uninstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UninstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Uninstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Uninstall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Uninstall(ctx, req.(*UninstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_WatchWorkloads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchWorkloadsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).WatchWorkloads(m, &connectorWatchWorkloadsServer{stream})
}

type Connector_WatchWorkloadsServer interface {
	Send(*WorkloadInfoSnapshot) error
	grpc.ServerStream
}

type connectorWatchWorkloadsServer struct {
	grpc.ServerStream
}

func (x *connectorWatchWorkloadsServer) Send(m *WorkloadInfoSnapshot) error {
	return x.ServerStream.SendMsg(m)
}

func _Connector_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Logout(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetCloudUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetCloudUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetCloudUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetCloudUserInfo(ctx, req.(*UserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetCloudAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetCloudAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetCloudAPIKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetCloudAPIKey(ctx, req.(*KeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetCloudLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetCloudLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetCloudLicense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetCloudLicense(ctx, req.(*LicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SetLogLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SetLogLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/SetLogLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SetLogLevel(ctx, req.(*LogLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Quit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Quit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/Quit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Quit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GatherLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GatherLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GatherLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GatherLogs(ctx, req.(*LogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GatherTraces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TracesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GatherTraces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GatherTraces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GatherTraces(ctx, req.(*TracesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_AddInterceptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interceptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).AddInterceptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/AddInterceptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).AddInterceptor(ctx, req.(*Interceptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoveInterceptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interceptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoveInterceptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/RemoveInterceptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoveInterceptor(ctx, req.(*Interceptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetNamespaces(ctx, req.(*GetNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_RemoteMountAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).RemoteMountAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/RemoteMountAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).RemoteMountAvailability(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.Connector/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Connector_ServiceDesc is the grpc.ServiceDesc for Connector service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Connector_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "telepresence.connector.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Connector_Version_Handler,
		},
		{
			MethodName: "RootDaemonVersion",
			Handler:    _Connector_RootDaemonVersion_Handler,
		},
		{
			MethodName: "TrafficManagerVersion",
			Handler:    _Connector_TrafficManagerVersion_Handler,
		},
		{
			MethodName: "GetIntercept",
			Handler:    _Connector_GetIntercept_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Connector_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Connector_Disconnect_Handler,
		},
		{
			MethodName: "GetClusterSubnets",
			Handler:    _Connector_GetClusterSubnets_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Connector_Status_Handler,
		},
		{
			MethodName: "CanIntercept",
			Handler:    _Connector_CanIntercept_Handler,
		},
		{
			MethodName: "CreateIntercept",
			Handler:    _Connector_CreateIntercept_Handler,
		},
		{
			MethodName: "RemoveIntercept",
			Handler:    _Connector_RemoveIntercept_Handler,
		},
		{
			MethodName: "UpdateIntercept",
			Handler:    _Connector_UpdateIntercept_Handler,
		},
		{
			MethodName: "Helm",
			Handler:    _Connector_Helm_Handler,
		},
		{
			MethodName: "Uninstall",
			Handler:    _Connector_Uninstall_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Connector_List_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Connector_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Connector_Logout_Handler,
		},
		{
			MethodName: "GetCloudUserInfo",
			Handler:    _Connector_GetCloudUserInfo_Handler,
		},
		{
			MethodName: "GetCloudAPIKey",
			Handler:    _Connector_GetCloudAPIKey_Handler,
		},
		{
			MethodName: "GetCloudLicense",
			Handler:    _Connector_GetCloudLicense_Handler,
		},
		{
			MethodName: "SetLogLevel",
			Handler:    _Connector_SetLogLevel_Handler,
		},
		{
			MethodName: "Quit",
			Handler:    _Connector_Quit_Handler,
		},
		{
			MethodName: "GatherLogs",
			Handler:    _Connector_GatherLogs_Handler,
		},
		{
			MethodName: "GatherTraces",
			Handler:    _Connector_GatherTraces_Handler,
		},
		{
			MethodName: "AddInterceptor",
			Handler:    _Connector_AddInterceptor_Handler,
		},
		{
			MethodName: "RemoveInterceptor",
			Handler:    _Connector_RemoveInterceptor_Handler,
		},
		{
			MethodName: "GetNamespaces",
			Handler:    _Connector_GetNamespaces_Handler,
		},
		{
			MethodName: "RemoteMountAvailability",
			Handler:    _Connector_RemoteMountAvailability_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Connector_GetConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchWorkloads",
			Handler:       _Connector_WatchWorkloads_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "connector/connector.proto",
}

// ManagerProxyClient is the client API for ManagerProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerProxyClient interface {
	// Version returns the version information of the Manager.
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.VersionInfo2, error)
	// GetClientConfig returns the config that connected clients should use for this manager.
	GetClientConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.CLIConfig, error)
	// WatchClusterInfo returns information needed when establishing
	// connectivity to the cluster.
	WatchClusterInfo(ctx context.Context, in *manager.SessionInfo, opts ...grpc.CallOption) (ManagerProxy_WatchClusterInfoClient, error)
	// LookupDNS performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	LookupDNS(ctx context.Context, in *manager.DNSRequest, opts ...grpc.CallOption) (*manager.DNSResponse, error)
	// LookupHost performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	// Deprecated: Retained for backward compatibility. Replaced by LookupDNS
	LookupHost(ctx context.Context, in *manager.LookupHostRequest, opts ...grpc.CallOption) (*manager.LookupHostResponse, error)
	// A Tunnel represents one single connection where the client or
	// traffic-agent represents one end (the client-side) and the
	// traffic-manager represents the other (the server side). The first
	// message that a client sends when the tunnel is established is will
	// always contain the session ID, connection ID, and timeouts used by
	// the dialer endpoints.
	Tunnel(ctx context.Context, opts ...grpc.CallOption) (ManagerProxy_TunnelClient, error)
}

type managerProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerProxyClient(cc grpc.ClientConnInterface) ManagerProxyClient {
	return &managerProxyClient{cc}
}

func (c *managerProxyClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.VersionInfo2, error) {
	out := new(manager.VersionInfo2)
	err := c.cc.Invoke(ctx, "/telepresence.connector.ManagerProxy/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) GetClientConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*manager.CLIConfig, error) {
	out := new(manager.CLIConfig)
	err := c.cc.Invoke(ctx, "/telepresence.connector.ManagerProxy/GetClientConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) WatchClusterInfo(ctx context.Context, in *manager.SessionInfo, opts ...grpc.CallOption) (ManagerProxy_WatchClusterInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerProxy_ServiceDesc.Streams[0], "/telepresence.connector.ManagerProxy/WatchClusterInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerProxyWatchClusterInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerProxy_WatchClusterInfoClient interface {
	Recv() (*manager.ClusterInfo, error)
	grpc.ClientStream
}

type managerProxyWatchClusterInfoClient struct {
	grpc.ClientStream
}

func (x *managerProxyWatchClusterInfoClient) Recv() (*manager.ClusterInfo, error) {
	m := new(manager.ClusterInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerProxyClient) LookupDNS(ctx context.Context, in *manager.DNSRequest, opts ...grpc.CallOption) (*manager.DNSResponse, error) {
	out := new(manager.DNSResponse)
	err := c.cc.Invoke(ctx, "/telepresence.connector.ManagerProxy/LookupDNS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) LookupHost(ctx context.Context, in *manager.LookupHostRequest, opts ...grpc.CallOption) (*manager.LookupHostResponse, error) {
	out := new(manager.LookupHostResponse)
	err := c.cc.Invoke(ctx, "/telepresence.connector.ManagerProxy/LookupHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerProxyClient) Tunnel(ctx context.Context, opts ...grpc.CallOption) (ManagerProxy_TunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerProxy_ServiceDesc.Streams[1], "/telepresence.connector.ManagerProxy/Tunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerProxyTunnelClient{stream}
	return x, nil
}

type ManagerProxy_TunnelClient interface {
	Send(*manager.TunnelMessage) error
	Recv() (*manager.TunnelMessage, error)
	grpc.ClientStream
}

type managerProxyTunnelClient struct {
	grpc.ClientStream
}

func (x *managerProxyTunnelClient) Send(m *manager.TunnelMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *managerProxyTunnelClient) Recv() (*manager.TunnelMessage, error) {
	m := new(manager.TunnelMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ManagerProxyServer is the server API for ManagerProxy service.
// All implementations must embed UnimplementedManagerProxyServer
// for forward compatibility
type ManagerProxyServer interface {
	// Version returns the version information of the Manager.
	Version(context.Context, *emptypb.Empty) (*manager.VersionInfo2, error)
	// GetClientConfig returns the config that connected clients should use for this manager.
	GetClientConfig(context.Context, *emptypb.Empty) (*manager.CLIConfig, error)
	// WatchClusterInfo returns information needed when establishing
	// connectivity to the cluster.
	WatchClusterInfo(*manager.SessionInfo, ManagerProxy_WatchClusterInfoServer) error
	// LookupDNS performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	LookupDNS(context.Context, *manager.DNSRequest) (*manager.DNSResponse, error)
	// LookupHost performs a DNS lookup in the cluster. If the caller has intercepts
	// active, the lookup will be performed from the intercepted pods.
	// Deprecated: Retained for backward compatibility. Replaced by LookupDNS
	LookupHost(context.Context, *manager.LookupHostRequest) (*manager.LookupHostResponse, error)
	// A Tunnel represents one single connection where the client or
	// traffic-agent represents one end (the client-side) and the
	// traffic-manager represents the other (the server side). The first
	// message that a client sends when the tunnel is established is will
	// always contain the session ID, connection ID, and timeouts used by
	// the dialer endpoints.
	Tunnel(ManagerProxy_TunnelServer) error
	mustEmbedUnimplementedManagerProxyServer()
}

// UnimplementedManagerProxyServer must be embedded to have forward compatible implementations.
type UnimplementedManagerProxyServer struct {
}

func (UnimplementedManagerProxyServer) Version(context.Context, *emptypb.Empty) (*manager.VersionInfo2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedManagerProxyServer) GetClientConfig(context.Context, *emptypb.Empty) (*manager.CLIConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClientConfig not implemented")
}
func (UnimplementedManagerProxyServer) WatchClusterInfo(*manager.SessionInfo, ManagerProxy_WatchClusterInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchClusterInfo not implemented")
}
func (UnimplementedManagerProxyServer) LookupDNS(context.Context, *manager.DNSRequest) (*manager.DNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupDNS not implemented")
}
func (UnimplementedManagerProxyServer) LookupHost(context.Context, *manager.LookupHostRequest) (*manager.LookupHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupHost not implemented")
}
func (UnimplementedManagerProxyServer) Tunnel(ManagerProxy_TunnelServer) error {
	return status.Errorf(codes.Unimplemented, "method Tunnel not implemented")
}
func (UnimplementedManagerProxyServer) mustEmbedUnimplementedManagerProxyServer() {}

// UnsafeManagerProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerProxyServer will
// result in compilation errors.
type UnsafeManagerProxyServer interface {
	mustEmbedUnimplementedManagerProxyServer()
}

func RegisterManagerProxyServer(s grpc.ServiceRegistrar, srv ManagerProxyServer) {
	s.RegisterService(&ManagerProxy_ServiceDesc, srv)
}

func _ManagerProxy_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.ManagerProxy/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_GetClientConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).GetClientConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.ManagerProxy/GetClientConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).GetClientConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_WatchClusterInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(manager.SessionInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerProxyServer).WatchClusterInfo(m, &managerProxyWatchClusterInfoServer{stream})
}

type ManagerProxy_WatchClusterInfoServer interface {
	Send(*manager.ClusterInfo) error
	grpc.ServerStream
}

type managerProxyWatchClusterInfoServer struct {
	grpc.ServerStream
}

func (x *managerProxyWatchClusterInfoServer) Send(m *manager.ClusterInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerProxy_LookupDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.DNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).LookupDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.ManagerProxy/LookupDNS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).LookupDNS(ctx, req.(*manager.DNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_LookupHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(manager.LookupHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerProxyServer).LookupHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telepresence.connector.ManagerProxy/LookupHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerProxyServer).LookupHost(ctx, req.(*manager.LookupHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerProxy_Tunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ManagerProxyServer).Tunnel(&managerProxyTunnelServer{stream})
}

type ManagerProxy_TunnelServer interface {
	Send(*manager.TunnelMessage) error
	Recv() (*manager.TunnelMessage, error)
	grpc.ServerStream
}

type managerProxyTunnelServer struct {
	grpc.ServerStream
}

func (x *managerProxyTunnelServer) Send(m *manager.TunnelMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *managerProxyTunnelServer) Recv() (*manager.TunnelMessage, error) {
	m := new(manager.TunnelMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ManagerProxy_ServiceDesc is the grpc.ServiceDesc for ManagerProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagerProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "telepresence.connector.ManagerProxy",
	HandlerType: (*ManagerProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _ManagerProxy_Version_Handler,
		},
		{
			MethodName: "GetClientConfig",
			Handler:    _ManagerProxy_GetClientConfig_Handler,
		},
		{
			MethodName: "LookupDNS",
			Handler:    _ManagerProxy_LookupDNS_Handler,
		},
		{
			MethodName: "LookupHost",
			Handler:    _ManagerProxy_LookupHost_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchClusterInfo",
			Handler:       _ManagerProxy_WatchClusterInfo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Tunnel",
			Handler:       _ManagerProxy_Tunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "connector/connector.proto",
}
